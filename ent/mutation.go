// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/vmkevv/rigelapi/ent/activity"
	"github.com/vmkevv/rigelapi/ent/activitysync"
	"github.com/vmkevv/rigelapi/ent/area"
	"github.com/vmkevv/rigelapi/ent/attendance"
	"github.com/vmkevv/rigelapi/ent/attendancesync"
	"github.com/vmkevv/rigelapi/ent/class"
	"github.com/vmkevv/rigelapi/ent/classperiod"
	"github.com/vmkevv/rigelapi/ent/classperiodsync"
	"github.com/vmkevv/rigelapi/ent/dpto"
	"github.com/vmkevv/rigelapi/ent/grade"
	"github.com/vmkevv/rigelapi/ent/municipio"
	"github.com/vmkevv/rigelapi/ent/period"
	"github.com/vmkevv/rigelapi/ent/predicate"
	"github.com/vmkevv/rigelapi/ent/provincia"
	"github.com/vmkevv/rigelapi/ent/school"
	"github.com/vmkevv/rigelapi/ent/score"
	"github.com/vmkevv/rigelapi/ent/scoresync"
	"github.com/vmkevv/rigelapi/ent/student"
	"github.com/vmkevv/rigelapi/ent/studentsync"
	"github.com/vmkevv/rigelapi/ent/subject"
	"github.com/vmkevv/rigelapi/ent/teacher"
	"github.com/vmkevv/rigelapi/ent/year"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActivity        = "Activity"
	TypeActivitySync    = "ActivitySync"
	TypeArea            = "Area"
	TypeAttendance      = "Attendance"
	TypeAttendanceSync  = "AttendanceSync"
	TypeClass           = "Class"
	TypeClassPeriod     = "ClassPeriod"
	TypeClassPeriodSync = "ClassPeriodSync"
	TypeDpto            = "Dpto"
	TypeGrade           = "Grade"
	TypeMunicipio       = "Municipio"
	TypePeriod          = "Period"
	TypeProvincia       = "Provincia"
	TypeSchool          = "School"
	TypeScore           = "Score"
	TypeScoreSync       = "ScoreSync"
	TypeStudent         = "Student"
	TypeStudentSync     = "StudentSync"
	TypeSubject         = "Subject"
	TypeTeacher         = "Teacher"
	TypeYear            = "Year"
)

// ActivityMutation represents an operation that mutates the Activity nodes in the graph.
type ActivityMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	name               *string
	date               *time.Time
	clearedFields      map[string]struct{}
	scores             map[string]struct{}
	removedscores      map[string]struct{}
	clearedscores      bool
	scoreSyncs         map[string]struct{}
	removedscoreSyncs  map[string]struct{}
	clearedscoreSyncs  bool
	area               *string
	clearedarea        bool
	classPeriod        *string
	clearedclassPeriod bool
	done               bool
	oldValue           func(context.Context) (*Activity, error)
	predicates         []predicate.Activity
}

var _ ent.Mutation = (*ActivityMutation)(nil)

// activityOption allows management of the mutation configuration using functional options.
type activityOption func(*ActivityMutation)

// newActivityMutation creates new mutation for the Activity entity.
func newActivityMutation(c config, op Op, opts ...activityOption) *ActivityMutation {
	m := &ActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityID sets the ID field of the mutation.
func withActivityID(id string) activityOption {
	return func(m *ActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *Activity
		)
		m.oldValue = func(ctx context.Context) (*Activity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Activity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivity sets the old Activity of the mutation.
func withActivity(node *Activity) activityOption {
	return func(m *ActivityMutation) {
		m.oldValue = func(context.Context) (*Activity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Activity entities.
func (m *ActivityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Activity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ActivityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ActivityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ActivityMutation) ResetName() {
	m.name = nil
}

// SetDate sets the "date" field.
func (m *ActivityMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *ActivityMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *ActivityMutation) ResetDate() {
	m.date = nil
}

// AddScoreIDs adds the "scores" edge to the Score entity by ids.
func (m *ActivityMutation) AddScoreIDs(ids ...string) {
	if m.scores == nil {
		m.scores = make(map[string]struct{})
	}
	for i := range ids {
		m.scores[ids[i]] = struct{}{}
	}
}

// ClearScores clears the "scores" edge to the Score entity.
func (m *ActivityMutation) ClearScores() {
	m.clearedscores = true
}

// ScoresCleared reports if the "scores" edge to the Score entity was cleared.
func (m *ActivityMutation) ScoresCleared() bool {
	return m.clearedscores
}

// RemoveScoreIDs removes the "scores" edge to the Score entity by IDs.
func (m *ActivityMutation) RemoveScoreIDs(ids ...string) {
	if m.removedscores == nil {
		m.removedscores = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.scores, ids[i])
		m.removedscores[ids[i]] = struct{}{}
	}
}

// RemovedScores returns the removed IDs of the "scores" edge to the Score entity.
func (m *ActivityMutation) RemovedScoresIDs() (ids []string) {
	for id := range m.removedscores {
		ids = append(ids, id)
	}
	return
}

// ScoresIDs returns the "scores" edge IDs in the mutation.
func (m *ActivityMutation) ScoresIDs() (ids []string) {
	for id := range m.scores {
		ids = append(ids, id)
	}
	return
}

// ResetScores resets all changes to the "scores" edge.
func (m *ActivityMutation) ResetScores() {
	m.scores = nil
	m.clearedscores = false
	m.removedscores = nil
}

// AddScoreSyncIDs adds the "scoreSyncs" edge to the ScoreSync entity by ids.
func (m *ActivityMutation) AddScoreSyncIDs(ids ...string) {
	if m.scoreSyncs == nil {
		m.scoreSyncs = make(map[string]struct{})
	}
	for i := range ids {
		m.scoreSyncs[ids[i]] = struct{}{}
	}
}

// ClearScoreSyncs clears the "scoreSyncs" edge to the ScoreSync entity.
func (m *ActivityMutation) ClearScoreSyncs() {
	m.clearedscoreSyncs = true
}

// ScoreSyncsCleared reports if the "scoreSyncs" edge to the ScoreSync entity was cleared.
func (m *ActivityMutation) ScoreSyncsCleared() bool {
	return m.clearedscoreSyncs
}

// RemoveScoreSyncIDs removes the "scoreSyncs" edge to the ScoreSync entity by IDs.
func (m *ActivityMutation) RemoveScoreSyncIDs(ids ...string) {
	if m.removedscoreSyncs == nil {
		m.removedscoreSyncs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.scoreSyncs, ids[i])
		m.removedscoreSyncs[ids[i]] = struct{}{}
	}
}

// RemovedScoreSyncs returns the removed IDs of the "scoreSyncs" edge to the ScoreSync entity.
func (m *ActivityMutation) RemovedScoreSyncsIDs() (ids []string) {
	for id := range m.removedscoreSyncs {
		ids = append(ids, id)
	}
	return
}

// ScoreSyncsIDs returns the "scoreSyncs" edge IDs in the mutation.
func (m *ActivityMutation) ScoreSyncsIDs() (ids []string) {
	for id := range m.scoreSyncs {
		ids = append(ids, id)
	}
	return
}

// ResetScoreSyncs resets all changes to the "scoreSyncs" edge.
func (m *ActivityMutation) ResetScoreSyncs() {
	m.scoreSyncs = nil
	m.clearedscoreSyncs = false
	m.removedscoreSyncs = nil
}

// SetAreaID sets the "area" edge to the Area entity by id.
func (m *ActivityMutation) SetAreaID(id string) {
	m.area = &id
}

// ClearArea clears the "area" edge to the Area entity.
func (m *ActivityMutation) ClearArea() {
	m.clearedarea = true
}

// AreaCleared reports if the "area" edge to the Area entity was cleared.
func (m *ActivityMutation) AreaCleared() bool {
	return m.clearedarea
}

// AreaID returns the "area" edge ID in the mutation.
func (m *ActivityMutation) AreaID() (id string, exists bool) {
	if m.area != nil {
		return *m.area, true
	}
	return
}

// AreaIDs returns the "area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AreaID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) AreaIDs() (ids []string) {
	if id := m.area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArea resets all changes to the "area" edge.
func (m *ActivityMutation) ResetArea() {
	m.area = nil
	m.clearedarea = false
}

// SetClassPeriodID sets the "classPeriod" edge to the ClassPeriod entity by id.
func (m *ActivityMutation) SetClassPeriodID(id string) {
	m.classPeriod = &id
}

// ClearClassPeriod clears the "classPeriod" edge to the ClassPeriod entity.
func (m *ActivityMutation) ClearClassPeriod() {
	m.clearedclassPeriod = true
}

// ClassPeriodCleared reports if the "classPeriod" edge to the ClassPeriod entity was cleared.
func (m *ActivityMutation) ClassPeriodCleared() bool {
	return m.clearedclassPeriod
}

// ClassPeriodID returns the "classPeriod" edge ID in the mutation.
func (m *ActivityMutation) ClassPeriodID() (id string, exists bool) {
	if m.classPeriod != nil {
		return *m.classPeriod, true
	}
	return
}

// ClassPeriodIDs returns the "classPeriod" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassPeriodID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) ClassPeriodIDs() (ids []string) {
	if id := m.classPeriod; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClassPeriod resets all changes to the "classPeriod" edge.
func (m *ActivityMutation) ResetClassPeriod() {
	m.classPeriod = nil
	m.clearedclassPeriod = false
}

// Where appends a list predicates to the ActivityMutation builder.
func (m *ActivityMutation) Where(ps ...predicate.Activity) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ActivityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Activity).
func (m *ActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, activity.FieldName)
	}
	if m.date != nil {
		fields = append(fields, activity.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldName:
		return m.Name()
	case activity.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activity.FieldName:
		return m.OldName(ctx)
	case activity.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown Activity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case activity.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Activity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Activity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityMutation) ResetField(name string) error {
	switch name {
	case activity.FieldName:
		m.ResetName()
		return nil
	case activity.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.scores != nil {
		edges = append(edges, activity.EdgeScores)
	}
	if m.scoreSyncs != nil {
		edges = append(edges, activity.EdgeScoreSyncs)
	}
	if m.area != nil {
		edges = append(edges, activity.EdgeArea)
	}
	if m.classPeriod != nil {
		edges = append(edges, activity.EdgeClassPeriod)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activity.EdgeScores:
		ids := make([]ent.Value, 0, len(m.scores))
		for id := range m.scores {
			ids = append(ids, id)
		}
		return ids
	case activity.EdgeScoreSyncs:
		ids := make([]ent.Value, 0, len(m.scoreSyncs))
		for id := range m.scoreSyncs {
			ids = append(ids, id)
		}
		return ids
	case activity.EdgeArea:
		if id := m.area; id != nil {
			return []ent.Value{*id}
		}
	case activity.EdgeClassPeriod:
		if id := m.classPeriod; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedscores != nil {
		edges = append(edges, activity.EdgeScores)
	}
	if m.removedscoreSyncs != nil {
		edges = append(edges, activity.EdgeScoreSyncs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case activity.EdgeScores:
		ids := make([]ent.Value, 0, len(m.removedscores))
		for id := range m.removedscores {
			ids = append(ids, id)
		}
		return ids
	case activity.EdgeScoreSyncs:
		ids := make([]ent.Value, 0, len(m.removedscoreSyncs))
		for id := range m.removedscoreSyncs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedscores {
		edges = append(edges, activity.EdgeScores)
	}
	if m.clearedscoreSyncs {
		edges = append(edges, activity.EdgeScoreSyncs)
	}
	if m.clearedarea {
		edges = append(edges, activity.EdgeArea)
	}
	if m.clearedclassPeriod {
		edges = append(edges, activity.EdgeClassPeriod)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case activity.EdgeScores:
		return m.clearedscores
	case activity.EdgeScoreSyncs:
		return m.clearedscoreSyncs
	case activity.EdgeArea:
		return m.clearedarea
	case activity.EdgeClassPeriod:
		return m.clearedclassPeriod
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityMutation) ClearEdge(name string) error {
	switch name {
	case activity.EdgeArea:
		m.ClearArea()
		return nil
	case activity.EdgeClassPeriod:
		m.ClearClassPeriod()
		return nil
	}
	return fmt.Errorf("unknown Activity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityMutation) ResetEdge(name string) error {
	switch name {
	case activity.EdgeScores:
		m.ResetScores()
		return nil
	case activity.EdgeScoreSyncs:
		m.ResetScoreSyncs()
		return nil
	case activity.EdgeArea:
		m.ResetArea()
		return nil
	case activity.EdgeClassPeriod:
		m.ResetClassPeriod()
		return nil
	}
	return fmt.Errorf("unknown Activity edge %s", name)
}

// ActivitySyncMutation represents an operation that mutates the ActivitySync nodes in the graph.
type ActivitySyncMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	last_sync_id       *string
	clearedFields      map[string]struct{}
	classPeriod        *string
	clearedclassPeriod bool
	done               bool
	oldValue           func(context.Context) (*ActivitySync, error)
	predicates         []predicate.ActivitySync
}

var _ ent.Mutation = (*ActivitySyncMutation)(nil)

// activitysyncOption allows management of the mutation configuration using functional options.
type activitysyncOption func(*ActivitySyncMutation)

// newActivitySyncMutation creates new mutation for the ActivitySync entity.
func newActivitySyncMutation(c config, op Op, opts ...activitysyncOption) *ActivitySyncMutation {
	m := &ActivitySyncMutation{
		config:        c,
		op:            op,
		typ:           TypeActivitySync,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivitySyncID sets the ID field of the mutation.
func withActivitySyncID(id string) activitysyncOption {
	return func(m *ActivitySyncMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivitySync
		)
		m.oldValue = func(ctx context.Context) (*ActivitySync, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivitySync.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivitySync sets the old ActivitySync of the mutation.
func withActivitySync(node *ActivitySync) activitysyncOption {
	return func(m *ActivitySyncMutation) {
		m.oldValue = func(context.Context) (*ActivitySync, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivitySyncMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivitySyncMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActivitySync entities.
func (m *ActivitySyncMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivitySyncMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivitySyncMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActivitySync.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLastSyncID sets the "last_sync_id" field.
func (m *ActivitySyncMutation) SetLastSyncID(s string) {
	m.last_sync_id = &s
}

// LastSyncID returns the value of the "last_sync_id" field in the mutation.
func (m *ActivitySyncMutation) LastSyncID() (r string, exists bool) {
	v := m.last_sync_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSyncID returns the old "last_sync_id" field's value of the ActivitySync entity.
// If the ActivitySync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivitySyncMutation) OldLastSyncID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSyncID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSyncID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSyncID: %w", err)
	}
	return oldValue.LastSyncID, nil
}

// ResetLastSyncID resets all changes to the "last_sync_id" field.
func (m *ActivitySyncMutation) ResetLastSyncID() {
	m.last_sync_id = nil
}

// SetClassPeriodID sets the "classPeriod" edge to the ClassPeriod entity by id.
func (m *ActivitySyncMutation) SetClassPeriodID(id string) {
	m.classPeriod = &id
}

// ClearClassPeriod clears the "classPeriod" edge to the ClassPeriod entity.
func (m *ActivitySyncMutation) ClearClassPeriod() {
	m.clearedclassPeriod = true
}

// ClassPeriodCleared reports if the "classPeriod" edge to the ClassPeriod entity was cleared.
func (m *ActivitySyncMutation) ClassPeriodCleared() bool {
	return m.clearedclassPeriod
}

// ClassPeriodID returns the "classPeriod" edge ID in the mutation.
func (m *ActivitySyncMutation) ClassPeriodID() (id string, exists bool) {
	if m.classPeriod != nil {
		return *m.classPeriod, true
	}
	return
}

// ClassPeriodIDs returns the "classPeriod" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassPeriodID instead. It exists only for internal usage by the builders.
func (m *ActivitySyncMutation) ClassPeriodIDs() (ids []string) {
	if id := m.classPeriod; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClassPeriod resets all changes to the "classPeriod" edge.
func (m *ActivitySyncMutation) ResetClassPeriod() {
	m.classPeriod = nil
	m.clearedclassPeriod = false
}

// Where appends a list predicates to the ActivitySyncMutation builder.
func (m *ActivitySyncMutation) Where(ps ...predicate.ActivitySync) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ActivitySyncMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ActivitySync).
func (m *ActivitySyncMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivitySyncMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.last_sync_id != nil {
		fields = append(fields, activitysync.FieldLastSyncID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivitySyncMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activitysync.FieldLastSyncID:
		return m.LastSyncID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivitySyncMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activitysync.FieldLastSyncID:
		return m.OldLastSyncID(ctx)
	}
	return nil, fmt.Errorf("unknown ActivitySync field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivitySyncMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activitysync.FieldLastSyncID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSyncID(v)
		return nil
	}
	return fmt.Errorf("unknown ActivitySync field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivitySyncMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivitySyncMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivitySyncMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActivitySync numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivitySyncMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivitySyncMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivitySyncMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ActivitySync nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivitySyncMutation) ResetField(name string) error {
	switch name {
	case activitysync.FieldLastSyncID:
		m.ResetLastSyncID()
		return nil
	}
	return fmt.Errorf("unknown ActivitySync field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivitySyncMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.classPeriod != nil {
		edges = append(edges, activitysync.EdgeClassPeriod)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivitySyncMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activitysync.EdgeClassPeriod:
		if id := m.classPeriod; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivitySyncMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivitySyncMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivitySyncMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedclassPeriod {
		edges = append(edges, activitysync.EdgeClassPeriod)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivitySyncMutation) EdgeCleared(name string) bool {
	switch name {
	case activitysync.EdgeClassPeriod:
		return m.clearedclassPeriod
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivitySyncMutation) ClearEdge(name string) error {
	switch name {
	case activitysync.EdgeClassPeriod:
		m.ClearClassPeriod()
		return nil
	}
	return fmt.Errorf("unknown ActivitySync unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivitySyncMutation) ResetEdge(name string) error {
	switch name {
	case activitysync.EdgeClassPeriod:
		m.ResetClassPeriod()
		return nil
	}
	return fmt.Errorf("unknown ActivitySync edge %s", name)
}

// AreaMutation represents an operation that mutates the Area nodes in the graph.
type AreaMutation struct {
	config
	op                Op
	typ               string
	id                *string
	name              *string
	points            *int
	addpoints         *int
	clearedFields     map[string]struct{}
	activities        map[string]struct{}
	removedactivities map[string]struct{}
	clearedactivities bool
	year              *string
	clearedyear       bool
	done              bool
	oldValue          func(context.Context) (*Area, error)
	predicates        []predicate.Area
}

var _ ent.Mutation = (*AreaMutation)(nil)

// areaOption allows management of the mutation configuration using functional options.
type areaOption func(*AreaMutation)

// newAreaMutation creates new mutation for the Area entity.
func newAreaMutation(c config, op Op, opts ...areaOption) *AreaMutation {
	m := &AreaMutation{
		config:        c,
		op:            op,
		typ:           TypeArea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAreaID sets the ID field of the mutation.
func withAreaID(id string) areaOption {
	return func(m *AreaMutation) {
		var (
			err   error
			once  sync.Once
			value *Area
		)
		m.oldValue = func(ctx context.Context) (*Area, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Area.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArea sets the old Area of the mutation.
func withArea(node *Area) areaOption {
	return func(m *AreaMutation) {
		m.oldValue = func(context.Context) (*Area, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AreaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AreaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Area entities.
func (m *AreaMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AreaMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AreaMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Area.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AreaMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AreaMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AreaMutation) ResetName() {
	m.name = nil
}

// SetPoints sets the "points" field.
func (m *AreaMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *AreaMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *AreaMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *AreaMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *AreaMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// AddActivityIDs adds the "activities" edge to the Activity entity by ids.
func (m *AreaMutation) AddActivityIDs(ids ...string) {
	if m.activities == nil {
		m.activities = make(map[string]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// ClearActivities clears the "activities" edge to the Activity entity.
func (m *AreaMutation) ClearActivities() {
	m.clearedactivities = true
}

// ActivitiesCleared reports if the "activities" edge to the Activity entity was cleared.
func (m *AreaMutation) ActivitiesCleared() bool {
	return m.clearedactivities
}

// RemoveActivityIDs removes the "activities" edge to the Activity entity by IDs.
func (m *AreaMutation) RemoveActivityIDs(ids ...string) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.activities, ids[i])
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed IDs of the "activities" edge to the Activity entity.
func (m *AreaMutation) RemovedActivitiesIDs() (ids []string) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the "activities" edge IDs in the mutation.
func (m *AreaMutation) ActivitiesIDs() (ids []string) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities resets all changes to the "activities" edge.
func (m *AreaMutation) ResetActivities() {
	m.activities = nil
	m.clearedactivities = false
	m.removedactivities = nil
}

// SetYearID sets the "year" edge to the Year entity by id.
func (m *AreaMutation) SetYearID(id string) {
	m.year = &id
}

// ClearYear clears the "year" edge to the Year entity.
func (m *AreaMutation) ClearYear() {
	m.clearedyear = true
}

// YearCleared reports if the "year" edge to the Year entity was cleared.
func (m *AreaMutation) YearCleared() bool {
	return m.clearedyear
}

// YearID returns the "year" edge ID in the mutation.
func (m *AreaMutation) YearID() (id string, exists bool) {
	if m.year != nil {
		return *m.year, true
	}
	return
}

// YearIDs returns the "year" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// YearID instead. It exists only for internal usage by the builders.
func (m *AreaMutation) YearIDs() (ids []string) {
	if id := m.year; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetYear resets all changes to the "year" edge.
func (m *AreaMutation) ResetYear() {
	m.year = nil
	m.clearedyear = false
}

// Where appends a list predicates to the AreaMutation builder.
func (m *AreaMutation) Where(ps ...predicate.Area) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AreaMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Area).
func (m *AreaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AreaMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, area.FieldName)
	}
	if m.points != nil {
		fields = append(fields, area.FieldPoints)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AreaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case area.FieldName:
		return m.Name()
	case area.FieldPoints:
		return m.Points()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AreaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case area.FieldName:
		return m.OldName(ctx)
	case area.FieldPoints:
		return m.OldPoints(ctx)
	}
	return nil, fmt.Errorf("unknown Area field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AreaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case area.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case area.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	}
	return fmt.Errorf("unknown Area field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AreaMutation) AddedFields() []string {
	var fields []string
	if m.addpoints != nil {
		fields = append(fields, area.FieldPoints)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AreaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case area.FieldPoints:
		return m.AddedPoints()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AreaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case area.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	}
	return fmt.Errorf("unknown Area numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AreaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AreaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AreaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Area nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AreaMutation) ResetField(name string) error {
	switch name {
	case area.FieldName:
		m.ResetName()
		return nil
	case area.FieldPoints:
		m.ResetPoints()
		return nil
	}
	return fmt.Errorf("unknown Area field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AreaMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.activities != nil {
		edges = append(edges, area.EdgeActivities)
	}
	if m.year != nil {
		edges = append(edges, area.EdgeYear)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AreaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case area.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	case area.EdgeYear:
		if id := m.year; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AreaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedactivities != nil {
		edges = append(edges, area.EdgeActivities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AreaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case area.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AreaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedactivities {
		edges = append(edges, area.EdgeActivities)
	}
	if m.clearedyear {
		edges = append(edges, area.EdgeYear)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AreaMutation) EdgeCleared(name string) bool {
	switch name {
	case area.EdgeActivities:
		return m.clearedactivities
	case area.EdgeYear:
		return m.clearedyear
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AreaMutation) ClearEdge(name string) error {
	switch name {
	case area.EdgeYear:
		m.ClearYear()
		return nil
	}
	return fmt.Errorf("unknown Area unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AreaMutation) ResetEdge(name string) error {
	switch name {
	case area.EdgeActivities:
		m.ResetActivities()
		return nil
	case area.EdgeYear:
		m.ResetYear()
		return nil
	}
	return fmt.Errorf("unknown Area edge %s", name)
}

// AttendanceMutation represents an operation that mutates the Attendance nodes in the graph.
type AttendanceMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	value              *attendance.Value
	clearedFields      map[string]struct{}
	classPeriod        *string
	clearedclassPeriod bool
	student            *string
	clearedstudent     bool
	done               bool
	oldValue           func(context.Context) (*Attendance, error)
	predicates         []predicate.Attendance
}

var _ ent.Mutation = (*AttendanceMutation)(nil)

// attendanceOption allows management of the mutation configuration using functional options.
type attendanceOption func(*AttendanceMutation)

// newAttendanceMutation creates new mutation for the Attendance entity.
func newAttendanceMutation(c config, op Op, opts ...attendanceOption) *AttendanceMutation {
	m := &AttendanceMutation{
		config:        c,
		op:            op,
		typ:           TypeAttendance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttendanceID sets the ID field of the mutation.
func withAttendanceID(id string) attendanceOption {
	return func(m *AttendanceMutation) {
		var (
			err   error
			once  sync.Once
			value *Attendance
		)
		m.oldValue = func(ctx context.Context) (*Attendance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attendance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttendance sets the old Attendance of the mutation.
func withAttendance(node *Attendance) attendanceOption {
	return func(m *AttendanceMutation) {
		m.oldValue = func(context.Context) (*Attendance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttendanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttendanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Attendance entities.
func (m *AttendanceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttendanceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttendanceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attendance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetValue sets the "value" field.
func (m *AttendanceMutation) SetValue(a attendance.Value) {
	m.value = &a
}

// Value returns the value of the "value" field in the mutation.
func (m *AttendanceMutation) Value() (r attendance.Value, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldValue(ctx context.Context) (v attendance.Value, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *AttendanceMutation) ResetValue() {
	m.value = nil
}

// SetClassPeriodID sets the "classPeriod" edge to the ClassPeriod entity by id.
func (m *AttendanceMutation) SetClassPeriodID(id string) {
	m.classPeriod = &id
}

// ClearClassPeriod clears the "classPeriod" edge to the ClassPeriod entity.
func (m *AttendanceMutation) ClearClassPeriod() {
	m.clearedclassPeriod = true
}

// ClassPeriodCleared reports if the "classPeriod" edge to the ClassPeriod entity was cleared.
func (m *AttendanceMutation) ClassPeriodCleared() bool {
	return m.clearedclassPeriod
}

// ClassPeriodID returns the "classPeriod" edge ID in the mutation.
func (m *AttendanceMutation) ClassPeriodID() (id string, exists bool) {
	if m.classPeriod != nil {
		return *m.classPeriod, true
	}
	return
}

// ClassPeriodIDs returns the "classPeriod" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassPeriodID instead. It exists only for internal usage by the builders.
func (m *AttendanceMutation) ClassPeriodIDs() (ids []string) {
	if id := m.classPeriod; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClassPeriod resets all changes to the "classPeriod" edge.
func (m *AttendanceMutation) ResetClassPeriod() {
	m.classPeriod = nil
	m.clearedclassPeriod = false
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *AttendanceMutation) SetStudentID(id string) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *AttendanceMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *AttendanceMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *AttendanceMutation) StudentID() (id string, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *AttendanceMutation) StudentIDs() (ids []string) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *AttendanceMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// Where appends a list predicates to the AttendanceMutation builder.
func (m *AttendanceMutation) Where(ps ...predicate.Attendance) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AttendanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Attendance).
func (m *AttendanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttendanceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.value != nil {
		fields = append(fields, attendance.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttendanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attendance.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttendanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attendance.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Attendance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttendanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attendance.FieldValue:
		v, ok := value.(attendance.Value)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Attendance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttendanceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttendanceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttendanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Attendance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttendanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttendanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttendanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Attendance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttendanceMutation) ResetField(name string) error {
	switch name {
	case attendance.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Attendance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttendanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.classPeriod != nil {
		edges = append(edges, attendance.EdgeClassPeriod)
	}
	if m.student != nil {
		edges = append(edges, attendance.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttendanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attendance.EdgeClassPeriod:
		if id := m.classPeriod; id != nil {
			return []ent.Value{*id}
		}
	case attendance.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttendanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttendanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttendanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedclassPeriod {
		edges = append(edges, attendance.EdgeClassPeriod)
	}
	if m.clearedstudent {
		edges = append(edges, attendance.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttendanceMutation) EdgeCleared(name string) bool {
	switch name {
	case attendance.EdgeClassPeriod:
		return m.clearedclassPeriod
	case attendance.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttendanceMutation) ClearEdge(name string) error {
	switch name {
	case attendance.EdgeClassPeriod:
		m.ClearClassPeriod()
		return nil
	case attendance.EdgeStudent:
		m.ClearStudent()
		return nil
	}
	return fmt.Errorf("unknown Attendance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttendanceMutation) ResetEdge(name string) error {
	switch name {
	case attendance.EdgeClassPeriod:
		m.ResetClassPeriod()
		return nil
	case attendance.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown Attendance edge %s", name)
}

// AttendanceSyncMutation represents an operation that mutates the AttendanceSync nodes in the graph.
type AttendanceSyncMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	last_sync_id       *string
	clearedFields      map[string]struct{}
	classPeriod        *string
	clearedclassPeriod bool
	done               bool
	oldValue           func(context.Context) (*AttendanceSync, error)
	predicates         []predicate.AttendanceSync
}

var _ ent.Mutation = (*AttendanceSyncMutation)(nil)

// attendancesyncOption allows management of the mutation configuration using functional options.
type attendancesyncOption func(*AttendanceSyncMutation)

// newAttendanceSyncMutation creates new mutation for the AttendanceSync entity.
func newAttendanceSyncMutation(c config, op Op, opts ...attendancesyncOption) *AttendanceSyncMutation {
	m := &AttendanceSyncMutation{
		config:        c,
		op:            op,
		typ:           TypeAttendanceSync,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttendanceSyncID sets the ID field of the mutation.
func withAttendanceSyncID(id string) attendancesyncOption {
	return func(m *AttendanceSyncMutation) {
		var (
			err   error
			once  sync.Once
			value *AttendanceSync
		)
		m.oldValue = func(ctx context.Context) (*AttendanceSync, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AttendanceSync.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttendanceSync sets the old AttendanceSync of the mutation.
func withAttendanceSync(node *AttendanceSync) attendancesyncOption {
	return func(m *AttendanceSyncMutation) {
		m.oldValue = func(context.Context) (*AttendanceSync, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttendanceSyncMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttendanceSyncMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AttendanceSync entities.
func (m *AttendanceSyncMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttendanceSyncMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttendanceSyncMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AttendanceSync.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLastSyncID sets the "last_sync_id" field.
func (m *AttendanceSyncMutation) SetLastSyncID(s string) {
	m.last_sync_id = &s
}

// LastSyncID returns the value of the "last_sync_id" field in the mutation.
func (m *AttendanceSyncMutation) LastSyncID() (r string, exists bool) {
	v := m.last_sync_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSyncID returns the old "last_sync_id" field's value of the AttendanceSync entity.
// If the AttendanceSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceSyncMutation) OldLastSyncID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSyncID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSyncID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSyncID: %w", err)
	}
	return oldValue.LastSyncID, nil
}

// ResetLastSyncID resets all changes to the "last_sync_id" field.
func (m *AttendanceSyncMutation) ResetLastSyncID() {
	m.last_sync_id = nil
}

// SetClassPeriodID sets the "classPeriod" edge to the ClassPeriod entity by id.
func (m *AttendanceSyncMutation) SetClassPeriodID(id string) {
	m.classPeriod = &id
}

// ClearClassPeriod clears the "classPeriod" edge to the ClassPeriod entity.
func (m *AttendanceSyncMutation) ClearClassPeriod() {
	m.clearedclassPeriod = true
}

// ClassPeriodCleared reports if the "classPeriod" edge to the ClassPeriod entity was cleared.
func (m *AttendanceSyncMutation) ClassPeriodCleared() bool {
	return m.clearedclassPeriod
}

// ClassPeriodID returns the "classPeriod" edge ID in the mutation.
func (m *AttendanceSyncMutation) ClassPeriodID() (id string, exists bool) {
	if m.classPeriod != nil {
		return *m.classPeriod, true
	}
	return
}

// ClassPeriodIDs returns the "classPeriod" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassPeriodID instead. It exists only for internal usage by the builders.
func (m *AttendanceSyncMutation) ClassPeriodIDs() (ids []string) {
	if id := m.classPeriod; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClassPeriod resets all changes to the "classPeriod" edge.
func (m *AttendanceSyncMutation) ResetClassPeriod() {
	m.classPeriod = nil
	m.clearedclassPeriod = false
}

// Where appends a list predicates to the AttendanceSyncMutation builder.
func (m *AttendanceSyncMutation) Where(ps ...predicate.AttendanceSync) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AttendanceSyncMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AttendanceSync).
func (m *AttendanceSyncMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttendanceSyncMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.last_sync_id != nil {
		fields = append(fields, attendancesync.FieldLastSyncID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttendanceSyncMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attendancesync.FieldLastSyncID:
		return m.LastSyncID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttendanceSyncMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attendancesync.FieldLastSyncID:
		return m.OldLastSyncID(ctx)
	}
	return nil, fmt.Errorf("unknown AttendanceSync field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttendanceSyncMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attendancesync.FieldLastSyncID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSyncID(v)
		return nil
	}
	return fmt.Errorf("unknown AttendanceSync field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttendanceSyncMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttendanceSyncMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttendanceSyncMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AttendanceSync numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttendanceSyncMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttendanceSyncMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttendanceSyncMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AttendanceSync nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttendanceSyncMutation) ResetField(name string) error {
	switch name {
	case attendancesync.FieldLastSyncID:
		m.ResetLastSyncID()
		return nil
	}
	return fmt.Errorf("unknown AttendanceSync field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttendanceSyncMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.classPeriod != nil {
		edges = append(edges, attendancesync.EdgeClassPeriod)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttendanceSyncMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attendancesync.EdgeClassPeriod:
		if id := m.classPeriod; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttendanceSyncMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttendanceSyncMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttendanceSyncMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedclassPeriod {
		edges = append(edges, attendancesync.EdgeClassPeriod)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttendanceSyncMutation) EdgeCleared(name string) bool {
	switch name {
	case attendancesync.EdgeClassPeriod:
		return m.clearedclassPeriod
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttendanceSyncMutation) ClearEdge(name string) error {
	switch name {
	case attendancesync.EdgeClassPeriod:
		m.ClearClassPeriod()
		return nil
	}
	return fmt.Errorf("unknown AttendanceSync unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttendanceSyncMutation) ResetEdge(name string) error {
	switch name {
	case attendancesync.EdgeClassPeriod:
		m.ResetClassPeriod()
		return nil
	}
	return fmt.Errorf("unknown AttendanceSync edge %s", name)
}

// ClassMutation represents an operation that mutates the Class nodes in the graph.
type ClassMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	parallel                *string
	clearedFields           map[string]struct{}
	students                map[string]struct{}
	removedstudents         map[string]struct{}
	clearedstudents         bool
	classPeriods            map[string]struct{}
	removedclassPeriods     map[string]struct{}
	clearedclassPeriods     bool
	classPeriodSyncs        map[string]struct{}
	removedclassPeriodSyncs map[string]struct{}
	clearedclassPeriodSyncs bool
	studentSyncs            map[string]struct{}
	removedstudentSyncs     map[string]struct{}
	clearedstudentSyncs     bool
	school                  *string
	clearedschool           bool
	teacher                 *string
	clearedteacher          bool
	subject                 *string
	clearedsubject          bool
	grade                   *string
	clearedgrade            bool
	year                    *string
	clearedyear             bool
	done                    bool
	oldValue                func(context.Context) (*Class, error)
	predicates              []predicate.Class
}

var _ ent.Mutation = (*ClassMutation)(nil)

// classOption allows management of the mutation configuration using functional options.
type classOption func(*ClassMutation)

// newClassMutation creates new mutation for the Class entity.
func newClassMutation(c config, op Op, opts ...classOption) *ClassMutation {
	m := &ClassMutation{
		config:        c,
		op:            op,
		typ:           TypeClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassID sets the ID field of the mutation.
func withClassID(id string) classOption {
	return func(m *ClassMutation) {
		var (
			err   error
			once  sync.Once
			value *Class
		)
		m.oldValue = func(ctx context.Context) (*Class, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Class.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClass sets the old Class of the mutation.
func withClass(node *Class) classOption {
	return func(m *ClassMutation) {
		m.oldValue = func(context.Context) (*Class, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Class entities.
func (m *ClassMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Class.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetParallel sets the "parallel" field.
func (m *ClassMutation) SetParallel(s string) {
	m.parallel = &s
}

// Parallel returns the value of the "parallel" field in the mutation.
func (m *ClassMutation) Parallel() (r string, exists bool) {
	v := m.parallel
	if v == nil {
		return
	}
	return *v, true
}

// OldParallel returns the old "parallel" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldParallel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParallel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParallel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParallel: %w", err)
	}
	return oldValue.Parallel, nil
}

// ResetParallel resets all changes to the "parallel" field.
func (m *ClassMutation) ResetParallel() {
	m.parallel = nil
}

// AddStudentIDs adds the "students" edge to the Student entity by ids.
func (m *ClassMutation) AddStudentIDs(ids ...string) {
	if m.students == nil {
		m.students = make(map[string]struct{})
	}
	for i := range ids {
		m.students[ids[i]] = struct{}{}
	}
}

// ClearStudents clears the "students" edge to the Student entity.
func (m *ClassMutation) ClearStudents() {
	m.clearedstudents = true
}

// StudentsCleared reports if the "students" edge to the Student entity was cleared.
func (m *ClassMutation) StudentsCleared() bool {
	return m.clearedstudents
}

// RemoveStudentIDs removes the "students" edge to the Student entity by IDs.
func (m *ClassMutation) RemoveStudentIDs(ids ...string) {
	if m.removedstudents == nil {
		m.removedstudents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.students, ids[i])
		m.removedstudents[ids[i]] = struct{}{}
	}
}

// RemovedStudents returns the removed IDs of the "students" edge to the Student entity.
func (m *ClassMutation) RemovedStudentsIDs() (ids []string) {
	for id := range m.removedstudents {
		ids = append(ids, id)
	}
	return
}

// StudentsIDs returns the "students" edge IDs in the mutation.
func (m *ClassMutation) StudentsIDs() (ids []string) {
	for id := range m.students {
		ids = append(ids, id)
	}
	return
}

// ResetStudents resets all changes to the "students" edge.
func (m *ClassMutation) ResetStudents() {
	m.students = nil
	m.clearedstudents = false
	m.removedstudents = nil
}

// AddClassPeriodIDs adds the "classPeriods" edge to the ClassPeriod entity by ids.
func (m *ClassMutation) AddClassPeriodIDs(ids ...string) {
	if m.classPeriods == nil {
		m.classPeriods = make(map[string]struct{})
	}
	for i := range ids {
		m.classPeriods[ids[i]] = struct{}{}
	}
}

// ClearClassPeriods clears the "classPeriods" edge to the ClassPeriod entity.
func (m *ClassMutation) ClearClassPeriods() {
	m.clearedclassPeriods = true
}

// ClassPeriodsCleared reports if the "classPeriods" edge to the ClassPeriod entity was cleared.
func (m *ClassMutation) ClassPeriodsCleared() bool {
	return m.clearedclassPeriods
}

// RemoveClassPeriodIDs removes the "classPeriods" edge to the ClassPeriod entity by IDs.
func (m *ClassMutation) RemoveClassPeriodIDs(ids ...string) {
	if m.removedclassPeriods == nil {
		m.removedclassPeriods = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.classPeriods, ids[i])
		m.removedclassPeriods[ids[i]] = struct{}{}
	}
}

// RemovedClassPeriods returns the removed IDs of the "classPeriods" edge to the ClassPeriod entity.
func (m *ClassMutation) RemovedClassPeriodsIDs() (ids []string) {
	for id := range m.removedclassPeriods {
		ids = append(ids, id)
	}
	return
}

// ClassPeriodsIDs returns the "classPeriods" edge IDs in the mutation.
func (m *ClassMutation) ClassPeriodsIDs() (ids []string) {
	for id := range m.classPeriods {
		ids = append(ids, id)
	}
	return
}

// ResetClassPeriods resets all changes to the "classPeriods" edge.
func (m *ClassMutation) ResetClassPeriods() {
	m.classPeriods = nil
	m.clearedclassPeriods = false
	m.removedclassPeriods = nil
}

// AddClassPeriodSyncIDs adds the "classPeriodSyncs" edge to the ClassPeriodSync entity by ids.
func (m *ClassMutation) AddClassPeriodSyncIDs(ids ...string) {
	if m.classPeriodSyncs == nil {
		m.classPeriodSyncs = make(map[string]struct{})
	}
	for i := range ids {
		m.classPeriodSyncs[ids[i]] = struct{}{}
	}
}

// ClearClassPeriodSyncs clears the "classPeriodSyncs" edge to the ClassPeriodSync entity.
func (m *ClassMutation) ClearClassPeriodSyncs() {
	m.clearedclassPeriodSyncs = true
}

// ClassPeriodSyncsCleared reports if the "classPeriodSyncs" edge to the ClassPeriodSync entity was cleared.
func (m *ClassMutation) ClassPeriodSyncsCleared() bool {
	return m.clearedclassPeriodSyncs
}

// RemoveClassPeriodSyncIDs removes the "classPeriodSyncs" edge to the ClassPeriodSync entity by IDs.
func (m *ClassMutation) RemoveClassPeriodSyncIDs(ids ...string) {
	if m.removedclassPeriodSyncs == nil {
		m.removedclassPeriodSyncs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.classPeriodSyncs, ids[i])
		m.removedclassPeriodSyncs[ids[i]] = struct{}{}
	}
}

// RemovedClassPeriodSyncs returns the removed IDs of the "classPeriodSyncs" edge to the ClassPeriodSync entity.
func (m *ClassMutation) RemovedClassPeriodSyncsIDs() (ids []string) {
	for id := range m.removedclassPeriodSyncs {
		ids = append(ids, id)
	}
	return
}

// ClassPeriodSyncsIDs returns the "classPeriodSyncs" edge IDs in the mutation.
func (m *ClassMutation) ClassPeriodSyncsIDs() (ids []string) {
	for id := range m.classPeriodSyncs {
		ids = append(ids, id)
	}
	return
}

// ResetClassPeriodSyncs resets all changes to the "classPeriodSyncs" edge.
func (m *ClassMutation) ResetClassPeriodSyncs() {
	m.classPeriodSyncs = nil
	m.clearedclassPeriodSyncs = false
	m.removedclassPeriodSyncs = nil
}

// AddStudentSyncIDs adds the "studentSyncs" edge to the StudentSync entity by ids.
func (m *ClassMutation) AddStudentSyncIDs(ids ...string) {
	if m.studentSyncs == nil {
		m.studentSyncs = make(map[string]struct{})
	}
	for i := range ids {
		m.studentSyncs[ids[i]] = struct{}{}
	}
}

// ClearStudentSyncs clears the "studentSyncs" edge to the StudentSync entity.
func (m *ClassMutation) ClearStudentSyncs() {
	m.clearedstudentSyncs = true
}

// StudentSyncsCleared reports if the "studentSyncs" edge to the StudentSync entity was cleared.
func (m *ClassMutation) StudentSyncsCleared() bool {
	return m.clearedstudentSyncs
}

// RemoveStudentSyncIDs removes the "studentSyncs" edge to the StudentSync entity by IDs.
func (m *ClassMutation) RemoveStudentSyncIDs(ids ...string) {
	if m.removedstudentSyncs == nil {
		m.removedstudentSyncs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.studentSyncs, ids[i])
		m.removedstudentSyncs[ids[i]] = struct{}{}
	}
}

// RemovedStudentSyncs returns the removed IDs of the "studentSyncs" edge to the StudentSync entity.
func (m *ClassMutation) RemovedStudentSyncsIDs() (ids []string) {
	for id := range m.removedstudentSyncs {
		ids = append(ids, id)
	}
	return
}

// StudentSyncsIDs returns the "studentSyncs" edge IDs in the mutation.
func (m *ClassMutation) StudentSyncsIDs() (ids []string) {
	for id := range m.studentSyncs {
		ids = append(ids, id)
	}
	return
}

// ResetStudentSyncs resets all changes to the "studentSyncs" edge.
func (m *ClassMutation) ResetStudentSyncs() {
	m.studentSyncs = nil
	m.clearedstudentSyncs = false
	m.removedstudentSyncs = nil
}

// SetSchoolID sets the "school" edge to the School entity by id.
func (m *ClassMutation) SetSchoolID(id string) {
	m.school = &id
}

// ClearSchool clears the "school" edge to the School entity.
func (m *ClassMutation) ClearSchool() {
	m.clearedschool = true
}

// SchoolCleared reports if the "school" edge to the School entity was cleared.
func (m *ClassMutation) SchoolCleared() bool {
	return m.clearedschool
}

// SchoolID returns the "school" edge ID in the mutation.
func (m *ClassMutation) SchoolID() (id string, exists bool) {
	if m.school != nil {
		return *m.school, true
	}
	return
}

// SchoolIDs returns the "school" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SchoolID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) SchoolIDs() (ids []string) {
	if id := m.school; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchool resets all changes to the "school" edge.
func (m *ClassMutation) ResetSchool() {
	m.school = nil
	m.clearedschool = false
}

// SetTeacherID sets the "teacher" edge to the Teacher entity by id.
func (m *ClassMutation) SetTeacherID(id string) {
	m.teacher = &id
}

// ClearTeacher clears the "teacher" edge to the Teacher entity.
func (m *ClassMutation) ClearTeacher() {
	m.clearedteacher = true
}

// TeacherCleared reports if the "teacher" edge to the Teacher entity was cleared.
func (m *ClassMutation) TeacherCleared() bool {
	return m.clearedteacher
}

// TeacherID returns the "teacher" edge ID in the mutation.
func (m *ClassMutation) TeacherID() (id string, exists bool) {
	if m.teacher != nil {
		return *m.teacher, true
	}
	return
}

// TeacherIDs returns the "teacher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeacherID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) TeacherIDs() (ids []string) {
	if id := m.teacher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeacher resets all changes to the "teacher" edge.
func (m *ClassMutation) ResetTeacher() {
	m.teacher = nil
	m.clearedteacher = false
}

// SetSubjectID sets the "subject" edge to the Subject entity by id.
func (m *ClassMutation) SetSubjectID(id string) {
	m.subject = &id
}

// ClearSubject clears the "subject" edge to the Subject entity.
func (m *ClassMutation) ClearSubject() {
	m.clearedsubject = true
}

// SubjectCleared reports if the "subject" edge to the Subject entity was cleared.
func (m *ClassMutation) SubjectCleared() bool {
	return m.clearedsubject
}

// SubjectID returns the "subject" edge ID in the mutation.
func (m *ClassMutation) SubjectID() (id string, exists bool) {
	if m.subject != nil {
		return *m.subject, true
	}
	return
}

// SubjectIDs returns the "subject" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubjectID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) SubjectIDs() (ids []string) {
	if id := m.subject; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubject resets all changes to the "subject" edge.
func (m *ClassMutation) ResetSubject() {
	m.subject = nil
	m.clearedsubject = false
}

// SetGradeID sets the "grade" edge to the Grade entity by id.
func (m *ClassMutation) SetGradeID(id string) {
	m.grade = &id
}

// ClearGrade clears the "grade" edge to the Grade entity.
func (m *ClassMutation) ClearGrade() {
	m.clearedgrade = true
}

// GradeCleared reports if the "grade" edge to the Grade entity was cleared.
func (m *ClassMutation) GradeCleared() bool {
	return m.clearedgrade
}

// GradeID returns the "grade" edge ID in the mutation.
func (m *ClassMutation) GradeID() (id string, exists bool) {
	if m.grade != nil {
		return *m.grade, true
	}
	return
}

// GradeIDs returns the "grade" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GradeID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) GradeIDs() (ids []string) {
	if id := m.grade; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGrade resets all changes to the "grade" edge.
func (m *ClassMutation) ResetGrade() {
	m.grade = nil
	m.clearedgrade = false
}

// SetYearID sets the "year" edge to the Year entity by id.
func (m *ClassMutation) SetYearID(id string) {
	m.year = &id
}

// ClearYear clears the "year" edge to the Year entity.
func (m *ClassMutation) ClearYear() {
	m.clearedyear = true
}

// YearCleared reports if the "year" edge to the Year entity was cleared.
func (m *ClassMutation) YearCleared() bool {
	return m.clearedyear
}

// YearID returns the "year" edge ID in the mutation.
func (m *ClassMutation) YearID() (id string, exists bool) {
	if m.year != nil {
		return *m.year, true
	}
	return
}

// YearIDs returns the "year" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// YearID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) YearIDs() (ids []string) {
	if id := m.year; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetYear resets all changes to the "year" edge.
func (m *ClassMutation) ResetYear() {
	m.year = nil
	m.clearedyear = false
}

// Where appends a list predicates to the ClassMutation builder.
func (m *ClassMutation) Where(ps ...predicate.Class) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ClassMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Class).
func (m *ClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.parallel != nil {
		fields = append(fields, class.FieldParallel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case class.FieldParallel:
		return m.Parallel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case class.FieldParallel:
		return m.OldParallel(ctx)
	}
	return nil, fmt.Errorf("unknown Class field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case class.FieldParallel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParallel(v)
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Class numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Class nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassMutation) ResetField(name string) error {
	switch name {
	case class.FieldParallel:
		m.ResetParallel()
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.students != nil {
		edges = append(edges, class.EdgeStudents)
	}
	if m.classPeriods != nil {
		edges = append(edges, class.EdgeClassPeriods)
	}
	if m.classPeriodSyncs != nil {
		edges = append(edges, class.EdgeClassPeriodSyncs)
	}
	if m.studentSyncs != nil {
		edges = append(edges, class.EdgeStudentSyncs)
	}
	if m.school != nil {
		edges = append(edges, class.EdgeSchool)
	}
	if m.teacher != nil {
		edges = append(edges, class.EdgeTeacher)
	}
	if m.subject != nil {
		edges = append(edges, class.EdgeSubject)
	}
	if m.grade != nil {
		edges = append(edges, class.EdgeGrade)
	}
	if m.year != nil {
		edges = append(edges, class.EdgeYear)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeStudents:
		ids := make([]ent.Value, 0, len(m.students))
		for id := range m.students {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeClassPeriods:
		ids := make([]ent.Value, 0, len(m.classPeriods))
		for id := range m.classPeriods {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeClassPeriodSyncs:
		ids := make([]ent.Value, 0, len(m.classPeriodSyncs))
		for id := range m.classPeriodSyncs {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeStudentSyncs:
		ids := make([]ent.Value, 0, len(m.studentSyncs))
		for id := range m.studentSyncs {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeSchool:
		if id := m.school; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeTeacher:
		if id := m.teacher; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeSubject:
		if id := m.subject; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeGrade:
		if id := m.grade; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeYear:
		if id := m.year; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedstudents != nil {
		edges = append(edges, class.EdgeStudents)
	}
	if m.removedclassPeriods != nil {
		edges = append(edges, class.EdgeClassPeriods)
	}
	if m.removedclassPeriodSyncs != nil {
		edges = append(edges, class.EdgeClassPeriodSyncs)
	}
	if m.removedstudentSyncs != nil {
		edges = append(edges, class.EdgeStudentSyncs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeStudents:
		ids := make([]ent.Value, 0, len(m.removedstudents))
		for id := range m.removedstudents {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeClassPeriods:
		ids := make([]ent.Value, 0, len(m.removedclassPeriods))
		for id := range m.removedclassPeriods {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeClassPeriodSyncs:
		ids := make([]ent.Value, 0, len(m.removedclassPeriodSyncs))
		for id := range m.removedclassPeriodSyncs {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeStudentSyncs:
		ids := make([]ent.Value, 0, len(m.removedstudentSyncs))
		for id := range m.removedstudentSyncs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedstudents {
		edges = append(edges, class.EdgeStudents)
	}
	if m.clearedclassPeriods {
		edges = append(edges, class.EdgeClassPeriods)
	}
	if m.clearedclassPeriodSyncs {
		edges = append(edges, class.EdgeClassPeriodSyncs)
	}
	if m.clearedstudentSyncs {
		edges = append(edges, class.EdgeStudentSyncs)
	}
	if m.clearedschool {
		edges = append(edges, class.EdgeSchool)
	}
	if m.clearedteacher {
		edges = append(edges, class.EdgeTeacher)
	}
	if m.clearedsubject {
		edges = append(edges, class.EdgeSubject)
	}
	if m.clearedgrade {
		edges = append(edges, class.EdgeGrade)
	}
	if m.clearedyear {
		edges = append(edges, class.EdgeYear)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassMutation) EdgeCleared(name string) bool {
	switch name {
	case class.EdgeStudents:
		return m.clearedstudents
	case class.EdgeClassPeriods:
		return m.clearedclassPeriods
	case class.EdgeClassPeriodSyncs:
		return m.clearedclassPeriodSyncs
	case class.EdgeStudentSyncs:
		return m.clearedstudentSyncs
	case class.EdgeSchool:
		return m.clearedschool
	case class.EdgeTeacher:
		return m.clearedteacher
	case class.EdgeSubject:
		return m.clearedsubject
	case class.EdgeGrade:
		return m.clearedgrade
	case class.EdgeYear:
		return m.clearedyear
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassMutation) ClearEdge(name string) error {
	switch name {
	case class.EdgeSchool:
		m.ClearSchool()
		return nil
	case class.EdgeTeacher:
		m.ClearTeacher()
		return nil
	case class.EdgeSubject:
		m.ClearSubject()
		return nil
	case class.EdgeGrade:
		m.ClearGrade()
		return nil
	case class.EdgeYear:
		m.ClearYear()
		return nil
	}
	return fmt.Errorf("unknown Class unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassMutation) ResetEdge(name string) error {
	switch name {
	case class.EdgeStudents:
		m.ResetStudents()
		return nil
	case class.EdgeClassPeriods:
		m.ResetClassPeriods()
		return nil
	case class.EdgeClassPeriodSyncs:
		m.ResetClassPeriodSyncs()
		return nil
	case class.EdgeStudentSyncs:
		m.ResetStudentSyncs()
		return nil
	case class.EdgeSchool:
		m.ResetSchool()
		return nil
	case class.EdgeTeacher:
		m.ResetTeacher()
		return nil
	case class.EdgeSubject:
		m.ResetSubject()
		return nil
	case class.EdgeGrade:
		m.ResetGrade()
		return nil
	case class.EdgeYear:
		m.ResetYear()
		return nil
	}
	return fmt.Errorf("unknown Class edge %s", name)
}

// ClassPeriodMutation represents an operation that mutates the ClassPeriod nodes in the graph.
type ClassPeriodMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	start                  *time.Time
	end                    *time.Time
	finished               *bool
	clearedFields          map[string]struct{}
	attendances            map[string]struct{}
	removedattendances     map[string]struct{}
	clearedattendances     bool
	attendanceSyncs        map[string]struct{}
	removedattendanceSyncs map[string]struct{}
	clearedattendanceSyncs bool
	activities             map[string]struct{}
	removedactivities      map[string]struct{}
	clearedactivities      bool
	activitySyncs          map[string]struct{}
	removedactivitySyncs   map[string]struct{}
	clearedactivitySyncs   bool
	class                  *string
	clearedclass           bool
	period                 *string
	clearedperiod          bool
	done                   bool
	oldValue               func(context.Context) (*ClassPeriod, error)
	predicates             []predicate.ClassPeriod
}

var _ ent.Mutation = (*ClassPeriodMutation)(nil)

// classperiodOption allows management of the mutation configuration using functional options.
type classperiodOption func(*ClassPeriodMutation)

// newClassPeriodMutation creates new mutation for the ClassPeriod entity.
func newClassPeriodMutation(c config, op Op, opts ...classperiodOption) *ClassPeriodMutation {
	m := &ClassPeriodMutation{
		config:        c,
		op:            op,
		typ:           TypeClassPeriod,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassPeriodID sets the ID field of the mutation.
func withClassPeriodID(id string) classperiodOption {
	return func(m *ClassPeriodMutation) {
		var (
			err   error
			once  sync.Once
			value *ClassPeriod
		)
		m.oldValue = func(ctx context.Context) (*ClassPeriod, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClassPeriod.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClassPeriod sets the old ClassPeriod of the mutation.
func withClassPeriod(node *ClassPeriod) classperiodOption {
	return func(m *ClassPeriodMutation) {
		m.oldValue = func(context.Context) (*ClassPeriod, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassPeriodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassPeriodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ClassPeriod entities.
func (m *ClassPeriodMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassPeriodMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassPeriodMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ClassPeriod.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStart sets the "start" field.
func (m *ClassPeriodMutation) SetStart(t time.Time) {
	m.start = &t
}

// Start returns the value of the "start" field in the mutation.
func (m *ClassPeriodMutation) Start() (r time.Time, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the ClassPeriod entity.
// If the ClassPeriod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassPeriodMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart resets all changes to the "start" field.
func (m *ClassPeriodMutation) ResetStart() {
	m.start = nil
}

// SetEnd sets the "end" field.
func (m *ClassPeriodMutation) SetEnd(t time.Time) {
	m.end = &t
}

// End returns the value of the "end" field in the mutation.
func (m *ClassPeriodMutation) End() (r time.Time, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the ClassPeriod entity.
// If the ClassPeriod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassPeriodMutation) OldEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ResetEnd resets all changes to the "end" field.
func (m *ClassPeriodMutation) ResetEnd() {
	m.end = nil
}

// SetFinished sets the "finished" field.
func (m *ClassPeriodMutation) SetFinished(b bool) {
	m.finished = &b
}

// Finished returns the value of the "finished" field in the mutation.
func (m *ClassPeriodMutation) Finished() (r bool, exists bool) {
	v := m.finished
	if v == nil {
		return
	}
	return *v, true
}

// OldFinished returns the old "finished" field's value of the ClassPeriod entity.
// If the ClassPeriod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassPeriodMutation) OldFinished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinished: %w", err)
	}
	return oldValue.Finished, nil
}

// ResetFinished resets all changes to the "finished" field.
func (m *ClassPeriodMutation) ResetFinished() {
	m.finished = nil
}

// AddAttendanceIDs adds the "attendances" edge to the Attendance entity by ids.
func (m *ClassPeriodMutation) AddAttendanceIDs(ids ...string) {
	if m.attendances == nil {
		m.attendances = make(map[string]struct{})
	}
	for i := range ids {
		m.attendances[ids[i]] = struct{}{}
	}
}

// ClearAttendances clears the "attendances" edge to the Attendance entity.
func (m *ClassPeriodMutation) ClearAttendances() {
	m.clearedattendances = true
}

// AttendancesCleared reports if the "attendances" edge to the Attendance entity was cleared.
func (m *ClassPeriodMutation) AttendancesCleared() bool {
	return m.clearedattendances
}

// RemoveAttendanceIDs removes the "attendances" edge to the Attendance entity by IDs.
func (m *ClassPeriodMutation) RemoveAttendanceIDs(ids ...string) {
	if m.removedattendances == nil {
		m.removedattendances = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.attendances, ids[i])
		m.removedattendances[ids[i]] = struct{}{}
	}
}

// RemovedAttendances returns the removed IDs of the "attendances" edge to the Attendance entity.
func (m *ClassPeriodMutation) RemovedAttendancesIDs() (ids []string) {
	for id := range m.removedattendances {
		ids = append(ids, id)
	}
	return
}

// AttendancesIDs returns the "attendances" edge IDs in the mutation.
func (m *ClassPeriodMutation) AttendancesIDs() (ids []string) {
	for id := range m.attendances {
		ids = append(ids, id)
	}
	return
}

// ResetAttendances resets all changes to the "attendances" edge.
func (m *ClassPeriodMutation) ResetAttendances() {
	m.attendances = nil
	m.clearedattendances = false
	m.removedattendances = nil
}

// AddAttendanceSyncIDs adds the "attendanceSyncs" edge to the AttendanceSync entity by ids.
func (m *ClassPeriodMutation) AddAttendanceSyncIDs(ids ...string) {
	if m.attendanceSyncs == nil {
		m.attendanceSyncs = make(map[string]struct{})
	}
	for i := range ids {
		m.attendanceSyncs[ids[i]] = struct{}{}
	}
}

// ClearAttendanceSyncs clears the "attendanceSyncs" edge to the AttendanceSync entity.
func (m *ClassPeriodMutation) ClearAttendanceSyncs() {
	m.clearedattendanceSyncs = true
}

// AttendanceSyncsCleared reports if the "attendanceSyncs" edge to the AttendanceSync entity was cleared.
func (m *ClassPeriodMutation) AttendanceSyncsCleared() bool {
	return m.clearedattendanceSyncs
}

// RemoveAttendanceSyncIDs removes the "attendanceSyncs" edge to the AttendanceSync entity by IDs.
func (m *ClassPeriodMutation) RemoveAttendanceSyncIDs(ids ...string) {
	if m.removedattendanceSyncs == nil {
		m.removedattendanceSyncs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.attendanceSyncs, ids[i])
		m.removedattendanceSyncs[ids[i]] = struct{}{}
	}
}

// RemovedAttendanceSyncs returns the removed IDs of the "attendanceSyncs" edge to the AttendanceSync entity.
func (m *ClassPeriodMutation) RemovedAttendanceSyncsIDs() (ids []string) {
	for id := range m.removedattendanceSyncs {
		ids = append(ids, id)
	}
	return
}

// AttendanceSyncsIDs returns the "attendanceSyncs" edge IDs in the mutation.
func (m *ClassPeriodMutation) AttendanceSyncsIDs() (ids []string) {
	for id := range m.attendanceSyncs {
		ids = append(ids, id)
	}
	return
}

// ResetAttendanceSyncs resets all changes to the "attendanceSyncs" edge.
func (m *ClassPeriodMutation) ResetAttendanceSyncs() {
	m.attendanceSyncs = nil
	m.clearedattendanceSyncs = false
	m.removedattendanceSyncs = nil
}

// AddActivityIDs adds the "activities" edge to the Activity entity by ids.
func (m *ClassPeriodMutation) AddActivityIDs(ids ...string) {
	if m.activities == nil {
		m.activities = make(map[string]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// ClearActivities clears the "activities" edge to the Activity entity.
func (m *ClassPeriodMutation) ClearActivities() {
	m.clearedactivities = true
}

// ActivitiesCleared reports if the "activities" edge to the Activity entity was cleared.
func (m *ClassPeriodMutation) ActivitiesCleared() bool {
	return m.clearedactivities
}

// RemoveActivityIDs removes the "activities" edge to the Activity entity by IDs.
func (m *ClassPeriodMutation) RemoveActivityIDs(ids ...string) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.activities, ids[i])
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed IDs of the "activities" edge to the Activity entity.
func (m *ClassPeriodMutation) RemovedActivitiesIDs() (ids []string) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the "activities" edge IDs in the mutation.
func (m *ClassPeriodMutation) ActivitiesIDs() (ids []string) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities resets all changes to the "activities" edge.
func (m *ClassPeriodMutation) ResetActivities() {
	m.activities = nil
	m.clearedactivities = false
	m.removedactivities = nil
}

// AddActivitySyncIDs adds the "activitySyncs" edge to the ActivitySync entity by ids.
func (m *ClassPeriodMutation) AddActivitySyncIDs(ids ...string) {
	if m.activitySyncs == nil {
		m.activitySyncs = make(map[string]struct{})
	}
	for i := range ids {
		m.activitySyncs[ids[i]] = struct{}{}
	}
}

// ClearActivitySyncs clears the "activitySyncs" edge to the ActivitySync entity.
func (m *ClassPeriodMutation) ClearActivitySyncs() {
	m.clearedactivitySyncs = true
}

// ActivitySyncsCleared reports if the "activitySyncs" edge to the ActivitySync entity was cleared.
func (m *ClassPeriodMutation) ActivitySyncsCleared() bool {
	return m.clearedactivitySyncs
}

// RemoveActivitySyncIDs removes the "activitySyncs" edge to the ActivitySync entity by IDs.
func (m *ClassPeriodMutation) RemoveActivitySyncIDs(ids ...string) {
	if m.removedactivitySyncs == nil {
		m.removedactivitySyncs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.activitySyncs, ids[i])
		m.removedactivitySyncs[ids[i]] = struct{}{}
	}
}

// RemovedActivitySyncs returns the removed IDs of the "activitySyncs" edge to the ActivitySync entity.
func (m *ClassPeriodMutation) RemovedActivitySyncsIDs() (ids []string) {
	for id := range m.removedactivitySyncs {
		ids = append(ids, id)
	}
	return
}

// ActivitySyncsIDs returns the "activitySyncs" edge IDs in the mutation.
func (m *ClassPeriodMutation) ActivitySyncsIDs() (ids []string) {
	for id := range m.activitySyncs {
		ids = append(ids, id)
	}
	return
}

// ResetActivitySyncs resets all changes to the "activitySyncs" edge.
func (m *ClassPeriodMutation) ResetActivitySyncs() {
	m.activitySyncs = nil
	m.clearedactivitySyncs = false
	m.removedactivitySyncs = nil
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *ClassPeriodMutation) SetClassID(id string) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *ClassPeriodMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *ClassPeriodMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *ClassPeriodMutation) ClassID() (id string, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *ClassPeriodMutation) ClassIDs() (ids []string) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *ClassPeriodMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// SetPeriodID sets the "period" edge to the Period entity by id.
func (m *ClassPeriodMutation) SetPeriodID(id string) {
	m.period = &id
}

// ClearPeriod clears the "period" edge to the Period entity.
func (m *ClassPeriodMutation) ClearPeriod() {
	m.clearedperiod = true
}

// PeriodCleared reports if the "period" edge to the Period entity was cleared.
func (m *ClassPeriodMutation) PeriodCleared() bool {
	return m.clearedperiod
}

// PeriodID returns the "period" edge ID in the mutation.
func (m *ClassPeriodMutation) PeriodID() (id string, exists bool) {
	if m.period != nil {
		return *m.period, true
	}
	return
}

// PeriodIDs returns the "period" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PeriodID instead. It exists only for internal usage by the builders.
func (m *ClassPeriodMutation) PeriodIDs() (ids []string) {
	if id := m.period; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPeriod resets all changes to the "period" edge.
func (m *ClassPeriodMutation) ResetPeriod() {
	m.period = nil
	m.clearedperiod = false
}

// Where appends a list predicates to the ClassPeriodMutation builder.
func (m *ClassPeriodMutation) Where(ps ...predicate.ClassPeriod) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ClassPeriodMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ClassPeriod).
func (m *ClassPeriodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassPeriodMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.start != nil {
		fields = append(fields, classperiod.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, classperiod.FieldEnd)
	}
	if m.finished != nil {
		fields = append(fields, classperiod.FieldFinished)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassPeriodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case classperiod.FieldStart:
		return m.Start()
	case classperiod.FieldEnd:
		return m.End()
	case classperiod.FieldFinished:
		return m.Finished()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassPeriodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case classperiod.FieldStart:
		return m.OldStart(ctx)
	case classperiod.FieldEnd:
		return m.OldEnd(ctx)
	case classperiod.FieldFinished:
		return m.OldFinished(ctx)
	}
	return nil, fmt.Errorf("unknown ClassPeriod field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassPeriodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case classperiod.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case classperiod.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case classperiod.FieldFinished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinished(v)
		return nil
	}
	return fmt.Errorf("unknown ClassPeriod field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassPeriodMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassPeriodMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassPeriodMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClassPeriod numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassPeriodMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassPeriodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassPeriodMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ClassPeriod nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassPeriodMutation) ResetField(name string) error {
	switch name {
	case classperiod.FieldStart:
		m.ResetStart()
		return nil
	case classperiod.FieldEnd:
		m.ResetEnd()
		return nil
	case classperiod.FieldFinished:
		m.ResetFinished()
		return nil
	}
	return fmt.Errorf("unknown ClassPeriod field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassPeriodMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.attendances != nil {
		edges = append(edges, classperiod.EdgeAttendances)
	}
	if m.attendanceSyncs != nil {
		edges = append(edges, classperiod.EdgeAttendanceSyncs)
	}
	if m.activities != nil {
		edges = append(edges, classperiod.EdgeActivities)
	}
	if m.activitySyncs != nil {
		edges = append(edges, classperiod.EdgeActivitySyncs)
	}
	if m.class != nil {
		edges = append(edges, classperiod.EdgeClass)
	}
	if m.period != nil {
		edges = append(edges, classperiod.EdgePeriod)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassPeriodMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case classperiod.EdgeAttendances:
		ids := make([]ent.Value, 0, len(m.attendances))
		for id := range m.attendances {
			ids = append(ids, id)
		}
		return ids
	case classperiod.EdgeAttendanceSyncs:
		ids := make([]ent.Value, 0, len(m.attendanceSyncs))
		for id := range m.attendanceSyncs {
			ids = append(ids, id)
		}
		return ids
	case classperiod.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	case classperiod.EdgeActivitySyncs:
		ids := make([]ent.Value, 0, len(m.activitySyncs))
		for id := range m.activitySyncs {
			ids = append(ids, id)
		}
		return ids
	case classperiod.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	case classperiod.EdgePeriod:
		if id := m.period; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassPeriodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedattendances != nil {
		edges = append(edges, classperiod.EdgeAttendances)
	}
	if m.removedattendanceSyncs != nil {
		edges = append(edges, classperiod.EdgeAttendanceSyncs)
	}
	if m.removedactivities != nil {
		edges = append(edges, classperiod.EdgeActivities)
	}
	if m.removedactivitySyncs != nil {
		edges = append(edges, classperiod.EdgeActivitySyncs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassPeriodMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case classperiod.EdgeAttendances:
		ids := make([]ent.Value, 0, len(m.removedattendances))
		for id := range m.removedattendances {
			ids = append(ids, id)
		}
		return ids
	case classperiod.EdgeAttendanceSyncs:
		ids := make([]ent.Value, 0, len(m.removedattendanceSyncs))
		for id := range m.removedattendanceSyncs {
			ids = append(ids, id)
		}
		return ids
	case classperiod.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	case classperiod.EdgeActivitySyncs:
		ids := make([]ent.Value, 0, len(m.removedactivitySyncs))
		for id := range m.removedactivitySyncs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassPeriodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedattendances {
		edges = append(edges, classperiod.EdgeAttendances)
	}
	if m.clearedattendanceSyncs {
		edges = append(edges, classperiod.EdgeAttendanceSyncs)
	}
	if m.clearedactivities {
		edges = append(edges, classperiod.EdgeActivities)
	}
	if m.clearedactivitySyncs {
		edges = append(edges, classperiod.EdgeActivitySyncs)
	}
	if m.clearedclass {
		edges = append(edges, classperiod.EdgeClass)
	}
	if m.clearedperiod {
		edges = append(edges, classperiod.EdgePeriod)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassPeriodMutation) EdgeCleared(name string) bool {
	switch name {
	case classperiod.EdgeAttendances:
		return m.clearedattendances
	case classperiod.EdgeAttendanceSyncs:
		return m.clearedattendanceSyncs
	case classperiod.EdgeActivities:
		return m.clearedactivities
	case classperiod.EdgeActivitySyncs:
		return m.clearedactivitySyncs
	case classperiod.EdgeClass:
		return m.clearedclass
	case classperiod.EdgePeriod:
		return m.clearedperiod
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassPeriodMutation) ClearEdge(name string) error {
	switch name {
	case classperiod.EdgeClass:
		m.ClearClass()
		return nil
	case classperiod.EdgePeriod:
		m.ClearPeriod()
		return nil
	}
	return fmt.Errorf("unknown ClassPeriod unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassPeriodMutation) ResetEdge(name string) error {
	switch name {
	case classperiod.EdgeAttendances:
		m.ResetAttendances()
		return nil
	case classperiod.EdgeAttendanceSyncs:
		m.ResetAttendanceSyncs()
		return nil
	case classperiod.EdgeActivities:
		m.ResetActivities()
		return nil
	case classperiod.EdgeActivitySyncs:
		m.ResetActivitySyncs()
		return nil
	case classperiod.EdgeClass:
		m.ResetClass()
		return nil
	case classperiod.EdgePeriod:
		m.ResetPeriod()
		return nil
	}
	return fmt.Errorf("unknown ClassPeriod edge %s", name)
}

// ClassPeriodSyncMutation represents an operation that mutates the ClassPeriodSync nodes in the graph.
type ClassPeriodSyncMutation struct {
	config
	op            Op
	typ           string
	id            *string
	last_sync_id  *string
	clearedFields map[string]struct{}
	class         *string
	clearedclass  bool
	done          bool
	oldValue      func(context.Context) (*ClassPeriodSync, error)
	predicates    []predicate.ClassPeriodSync
}

var _ ent.Mutation = (*ClassPeriodSyncMutation)(nil)

// classperiodsyncOption allows management of the mutation configuration using functional options.
type classperiodsyncOption func(*ClassPeriodSyncMutation)

// newClassPeriodSyncMutation creates new mutation for the ClassPeriodSync entity.
func newClassPeriodSyncMutation(c config, op Op, opts ...classperiodsyncOption) *ClassPeriodSyncMutation {
	m := &ClassPeriodSyncMutation{
		config:        c,
		op:            op,
		typ:           TypeClassPeriodSync,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassPeriodSyncID sets the ID field of the mutation.
func withClassPeriodSyncID(id string) classperiodsyncOption {
	return func(m *ClassPeriodSyncMutation) {
		var (
			err   error
			once  sync.Once
			value *ClassPeriodSync
		)
		m.oldValue = func(ctx context.Context) (*ClassPeriodSync, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClassPeriodSync.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClassPeriodSync sets the old ClassPeriodSync of the mutation.
func withClassPeriodSync(node *ClassPeriodSync) classperiodsyncOption {
	return func(m *ClassPeriodSyncMutation) {
		m.oldValue = func(context.Context) (*ClassPeriodSync, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassPeriodSyncMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassPeriodSyncMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ClassPeriodSync entities.
func (m *ClassPeriodSyncMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassPeriodSyncMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassPeriodSyncMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ClassPeriodSync.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLastSyncID sets the "last_sync_id" field.
func (m *ClassPeriodSyncMutation) SetLastSyncID(s string) {
	m.last_sync_id = &s
}

// LastSyncID returns the value of the "last_sync_id" field in the mutation.
func (m *ClassPeriodSyncMutation) LastSyncID() (r string, exists bool) {
	v := m.last_sync_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSyncID returns the old "last_sync_id" field's value of the ClassPeriodSync entity.
// If the ClassPeriodSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassPeriodSyncMutation) OldLastSyncID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSyncID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSyncID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSyncID: %w", err)
	}
	return oldValue.LastSyncID, nil
}

// ResetLastSyncID resets all changes to the "last_sync_id" field.
func (m *ClassPeriodSyncMutation) ResetLastSyncID() {
	m.last_sync_id = nil
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *ClassPeriodSyncMutation) SetClassID(id string) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *ClassPeriodSyncMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *ClassPeriodSyncMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *ClassPeriodSyncMutation) ClassID() (id string, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *ClassPeriodSyncMutation) ClassIDs() (ids []string) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *ClassPeriodSyncMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// Where appends a list predicates to the ClassPeriodSyncMutation builder.
func (m *ClassPeriodSyncMutation) Where(ps ...predicate.ClassPeriodSync) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ClassPeriodSyncMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ClassPeriodSync).
func (m *ClassPeriodSyncMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassPeriodSyncMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.last_sync_id != nil {
		fields = append(fields, classperiodsync.FieldLastSyncID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassPeriodSyncMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case classperiodsync.FieldLastSyncID:
		return m.LastSyncID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassPeriodSyncMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case classperiodsync.FieldLastSyncID:
		return m.OldLastSyncID(ctx)
	}
	return nil, fmt.Errorf("unknown ClassPeriodSync field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassPeriodSyncMutation) SetField(name string, value ent.Value) error {
	switch name {
	case classperiodsync.FieldLastSyncID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSyncID(v)
		return nil
	}
	return fmt.Errorf("unknown ClassPeriodSync field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassPeriodSyncMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassPeriodSyncMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassPeriodSyncMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClassPeriodSync numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassPeriodSyncMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassPeriodSyncMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassPeriodSyncMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ClassPeriodSync nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassPeriodSyncMutation) ResetField(name string) error {
	switch name {
	case classperiodsync.FieldLastSyncID:
		m.ResetLastSyncID()
		return nil
	}
	return fmt.Errorf("unknown ClassPeriodSync field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassPeriodSyncMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.class != nil {
		edges = append(edges, classperiodsync.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassPeriodSyncMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case classperiodsync.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassPeriodSyncMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassPeriodSyncMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassPeriodSyncMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedclass {
		edges = append(edges, classperiodsync.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassPeriodSyncMutation) EdgeCleared(name string) bool {
	switch name {
	case classperiodsync.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassPeriodSyncMutation) ClearEdge(name string) error {
	switch name {
	case classperiodsync.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown ClassPeriodSync unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassPeriodSyncMutation) ResetEdge(name string) error {
	switch name {
	case classperiodsync.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown ClassPeriodSync edge %s", name)
}

// DptoMutation represents an operation that mutates the Dpto nodes in the graph.
type DptoMutation struct {
	config
	op                Op
	typ               string
	id                *string
	name              *string
	clearedFields     map[string]struct{}
	provincias        map[string]struct{}
	removedprovincias map[string]struct{}
	clearedprovincias bool
	done              bool
	oldValue          func(context.Context) (*Dpto, error)
	predicates        []predicate.Dpto
}

var _ ent.Mutation = (*DptoMutation)(nil)

// dptoOption allows management of the mutation configuration using functional options.
type dptoOption func(*DptoMutation)

// newDptoMutation creates new mutation for the Dpto entity.
func newDptoMutation(c config, op Op, opts ...dptoOption) *DptoMutation {
	m := &DptoMutation{
		config:        c,
		op:            op,
		typ:           TypeDpto,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDptoID sets the ID field of the mutation.
func withDptoID(id string) dptoOption {
	return func(m *DptoMutation) {
		var (
			err   error
			once  sync.Once
			value *Dpto
		)
		m.oldValue = func(ctx context.Context) (*Dpto, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dpto.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDpto sets the old Dpto of the mutation.
func withDpto(node *Dpto) dptoOption {
	return func(m *DptoMutation) {
		m.oldValue = func(context.Context) (*Dpto, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DptoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DptoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dpto entities.
func (m *DptoMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DptoMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DptoMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dpto.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DptoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DptoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Dpto entity.
// If the Dpto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DptoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DptoMutation) ResetName() {
	m.name = nil
}

// AddProvinciaIDs adds the "provincias" edge to the Provincia entity by ids.
func (m *DptoMutation) AddProvinciaIDs(ids ...string) {
	if m.provincias == nil {
		m.provincias = make(map[string]struct{})
	}
	for i := range ids {
		m.provincias[ids[i]] = struct{}{}
	}
}

// ClearProvincias clears the "provincias" edge to the Provincia entity.
func (m *DptoMutation) ClearProvincias() {
	m.clearedprovincias = true
}

// ProvinciasCleared reports if the "provincias" edge to the Provincia entity was cleared.
func (m *DptoMutation) ProvinciasCleared() bool {
	return m.clearedprovincias
}

// RemoveProvinciaIDs removes the "provincias" edge to the Provincia entity by IDs.
func (m *DptoMutation) RemoveProvinciaIDs(ids ...string) {
	if m.removedprovincias == nil {
		m.removedprovincias = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.provincias, ids[i])
		m.removedprovincias[ids[i]] = struct{}{}
	}
}

// RemovedProvincias returns the removed IDs of the "provincias" edge to the Provincia entity.
func (m *DptoMutation) RemovedProvinciasIDs() (ids []string) {
	for id := range m.removedprovincias {
		ids = append(ids, id)
	}
	return
}

// ProvinciasIDs returns the "provincias" edge IDs in the mutation.
func (m *DptoMutation) ProvinciasIDs() (ids []string) {
	for id := range m.provincias {
		ids = append(ids, id)
	}
	return
}

// ResetProvincias resets all changes to the "provincias" edge.
func (m *DptoMutation) ResetProvincias() {
	m.provincias = nil
	m.clearedprovincias = false
	m.removedprovincias = nil
}

// Where appends a list predicates to the DptoMutation builder.
func (m *DptoMutation) Where(ps ...predicate.Dpto) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DptoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Dpto).
func (m *DptoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DptoMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, dpto.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DptoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dpto.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DptoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dpto.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Dpto field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DptoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dpto.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Dpto field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DptoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DptoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DptoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Dpto numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DptoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DptoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DptoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Dpto nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DptoMutation) ResetField(name string) error {
	switch name {
	case dpto.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Dpto field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DptoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.provincias != nil {
		edges = append(edges, dpto.EdgeProvincias)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DptoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dpto.EdgeProvincias:
		ids := make([]ent.Value, 0, len(m.provincias))
		for id := range m.provincias {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DptoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprovincias != nil {
		edges = append(edges, dpto.EdgeProvincias)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DptoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dpto.EdgeProvincias:
		ids := make([]ent.Value, 0, len(m.removedprovincias))
		for id := range m.removedprovincias {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DptoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprovincias {
		edges = append(edges, dpto.EdgeProvincias)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DptoMutation) EdgeCleared(name string) bool {
	switch name {
	case dpto.EdgeProvincias:
		return m.clearedprovincias
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DptoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Dpto unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DptoMutation) ResetEdge(name string) error {
	switch name {
	case dpto.EdgeProvincias:
		m.ResetProvincias()
		return nil
	}
	return fmt.Errorf("unknown Dpto edge %s", name)
}

// GradeMutation represents an operation that mutates the Grade nodes in the graph.
type GradeMutation struct {
	config
	op             Op
	typ            string
	id             *string
	name           *string
	clearedFields  map[string]struct{}
	classes        map[string]struct{}
	removedclasses map[string]struct{}
	clearedclasses bool
	done           bool
	oldValue       func(context.Context) (*Grade, error)
	predicates     []predicate.Grade
}

var _ ent.Mutation = (*GradeMutation)(nil)

// gradeOption allows management of the mutation configuration using functional options.
type gradeOption func(*GradeMutation)

// newGradeMutation creates new mutation for the Grade entity.
func newGradeMutation(c config, op Op, opts ...gradeOption) *GradeMutation {
	m := &GradeMutation{
		config:        c,
		op:            op,
		typ:           TypeGrade,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGradeID sets the ID field of the mutation.
func withGradeID(id string) gradeOption {
	return func(m *GradeMutation) {
		var (
			err   error
			once  sync.Once
			value *Grade
		)
		m.oldValue = func(ctx context.Context) (*Grade, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Grade.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGrade sets the old Grade of the mutation.
func withGrade(node *Grade) gradeOption {
	return func(m *GradeMutation) {
		m.oldValue = func(context.Context) (*Grade, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GradeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GradeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Grade entities.
func (m *GradeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GradeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GradeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Grade.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *GradeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GradeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Grade entity.
// If the Grade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GradeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GradeMutation) ResetName() {
	m.name = nil
}

// AddClassIDs adds the "classes" edge to the Class entity by ids.
func (m *GradeMutation) AddClassIDs(ids ...string) {
	if m.classes == nil {
		m.classes = make(map[string]struct{})
	}
	for i := range ids {
		m.classes[ids[i]] = struct{}{}
	}
}

// ClearClasses clears the "classes" edge to the Class entity.
func (m *GradeMutation) ClearClasses() {
	m.clearedclasses = true
}

// ClassesCleared reports if the "classes" edge to the Class entity was cleared.
func (m *GradeMutation) ClassesCleared() bool {
	return m.clearedclasses
}

// RemoveClassIDs removes the "classes" edge to the Class entity by IDs.
func (m *GradeMutation) RemoveClassIDs(ids ...string) {
	if m.removedclasses == nil {
		m.removedclasses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.classes, ids[i])
		m.removedclasses[ids[i]] = struct{}{}
	}
}

// RemovedClasses returns the removed IDs of the "classes" edge to the Class entity.
func (m *GradeMutation) RemovedClassesIDs() (ids []string) {
	for id := range m.removedclasses {
		ids = append(ids, id)
	}
	return
}

// ClassesIDs returns the "classes" edge IDs in the mutation.
func (m *GradeMutation) ClassesIDs() (ids []string) {
	for id := range m.classes {
		ids = append(ids, id)
	}
	return
}

// ResetClasses resets all changes to the "classes" edge.
func (m *GradeMutation) ResetClasses() {
	m.classes = nil
	m.clearedclasses = false
	m.removedclasses = nil
}

// Where appends a list predicates to the GradeMutation builder.
func (m *GradeMutation) Where(ps ...predicate.Grade) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GradeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Grade).
func (m *GradeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GradeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, grade.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GradeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grade.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GradeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case grade.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Grade field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GradeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grade.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Grade field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GradeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GradeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GradeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Grade numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GradeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GradeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GradeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Grade nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GradeMutation) ResetField(name string) error {
	switch name {
	case grade.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Grade field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GradeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.classes != nil {
		edges = append(edges, grade.EdgeClasses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GradeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case grade.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.classes))
		for id := range m.classes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GradeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedclasses != nil {
		edges = append(edges, grade.EdgeClasses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GradeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case grade.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.removedclasses))
		for id := range m.removedclasses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GradeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedclasses {
		edges = append(edges, grade.EdgeClasses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GradeMutation) EdgeCleared(name string) bool {
	switch name {
	case grade.EdgeClasses:
		return m.clearedclasses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GradeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Grade unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GradeMutation) ResetEdge(name string) error {
	switch name {
	case grade.EdgeClasses:
		m.ResetClasses()
		return nil
	}
	return fmt.Errorf("unknown Grade edge %s", name)
}

// MunicipioMutation represents an operation that mutates the Municipio nodes in the graph.
type MunicipioMutation struct {
	config
	op               Op
	typ              string
	id               *string
	name             *string
	clearedFields    map[string]struct{}
	schools          map[string]struct{}
	removedschools   map[string]struct{}
	clearedschools   bool
	provincia        *string
	clearedprovincia bool
	done             bool
	oldValue         func(context.Context) (*Municipio, error)
	predicates       []predicate.Municipio
}

var _ ent.Mutation = (*MunicipioMutation)(nil)

// municipioOption allows management of the mutation configuration using functional options.
type municipioOption func(*MunicipioMutation)

// newMunicipioMutation creates new mutation for the Municipio entity.
func newMunicipioMutation(c config, op Op, opts ...municipioOption) *MunicipioMutation {
	m := &MunicipioMutation{
		config:        c,
		op:            op,
		typ:           TypeMunicipio,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMunicipioID sets the ID field of the mutation.
func withMunicipioID(id string) municipioOption {
	return func(m *MunicipioMutation) {
		var (
			err   error
			once  sync.Once
			value *Municipio
		)
		m.oldValue = func(ctx context.Context) (*Municipio, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Municipio.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMunicipio sets the old Municipio of the mutation.
func withMunicipio(node *Municipio) municipioOption {
	return func(m *MunicipioMutation) {
		m.oldValue = func(context.Context) (*Municipio, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MunicipioMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MunicipioMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Municipio entities.
func (m *MunicipioMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MunicipioMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MunicipioMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Municipio.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MunicipioMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MunicipioMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Municipio entity.
// If the Municipio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MunicipioMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MunicipioMutation) ResetName() {
	m.name = nil
}

// AddSchoolIDs adds the "schools" edge to the School entity by ids.
func (m *MunicipioMutation) AddSchoolIDs(ids ...string) {
	if m.schools == nil {
		m.schools = make(map[string]struct{})
	}
	for i := range ids {
		m.schools[ids[i]] = struct{}{}
	}
}

// ClearSchools clears the "schools" edge to the School entity.
func (m *MunicipioMutation) ClearSchools() {
	m.clearedschools = true
}

// SchoolsCleared reports if the "schools" edge to the School entity was cleared.
func (m *MunicipioMutation) SchoolsCleared() bool {
	return m.clearedschools
}

// RemoveSchoolIDs removes the "schools" edge to the School entity by IDs.
func (m *MunicipioMutation) RemoveSchoolIDs(ids ...string) {
	if m.removedschools == nil {
		m.removedschools = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.schools, ids[i])
		m.removedschools[ids[i]] = struct{}{}
	}
}

// RemovedSchools returns the removed IDs of the "schools" edge to the School entity.
func (m *MunicipioMutation) RemovedSchoolsIDs() (ids []string) {
	for id := range m.removedschools {
		ids = append(ids, id)
	}
	return
}

// SchoolsIDs returns the "schools" edge IDs in the mutation.
func (m *MunicipioMutation) SchoolsIDs() (ids []string) {
	for id := range m.schools {
		ids = append(ids, id)
	}
	return
}

// ResetSchools resets all changes to the "schools" edge.
func (m *MunicipioMutation) ResetSchools() {
	m.schools = nil
	m.clearedschools = false
	m.removedschools = nil
}

// SetProvinciaID sets the "provincia" edge to the Provincia entity by id.
func (m *MunicipioMutation) SetProvinciaID(id string) {
	m.provincia = &id
}

// ClearProvincia clears the "provincia" edge to the Provincia entity.
func (m *MunicipioMutation) ClearProvincia() {
	m.clearedprovincia = true
}

// ProvinciaCleared reports if the "provincia" edge to the Provincia entity was cleared.
func (m *MunicipioMutation) ProvinciaCleared() bool {
	return m.clearedprovincia
}

// ProvinciaID returns the "provincia" edge ID in the mutation.
func (m *MunicipioMutation) ProvinciaID() (id string, exists bool) {
	if m.provincia != nil {
		return *m.provincia, true
	}
	return
}

// ProvinciaIDs returns the "provincia" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvinciaID instead. It exists only for internal usage by the builders.
func (m *MunicipioMutation) ProvinciaIDs() (ids []string) {
	if id := m.provincia; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvincia resets all changes to the "provincia" edge.
func (m *MunicipioMutation) ResetProvincia() {
	m.provincia = nil
	m.clearedprovincia = false
}

// Where appends a list predicates to the MunicipioMutation builder.
func (m *MunicipioMutation) Where(ps ...predicate.Municipio) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MunicipioMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Municipio).
func (m *MunicipioMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MunicipioMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, municipio.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MunicipioMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case municipio.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MunicipioMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case municipio.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Municipio field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MunicipioMutation) SetField(name string, value ent.Value) error {
	switch name {
	case municipio.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Municipio field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MunicipioMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MunicipioMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MunicipioMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Municipio numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MunicipioMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MunicipioMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MunicipioMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Municipio nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MunicipioMutation) ResetField(name string) error {
	switch name {
	case municipio.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Municipio field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MunicipioMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.schools != nil {
		edges = append(edges, municipio.EdgeSchools)
	}
	if m.provincia != nil {
		edges = append(edges, municipio.EdgeProvincia)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MunicipioMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case municipio.EdgeSchools:
		ids := make([]ent.Value, 0, len(m.schools))
		for id := range m.schools {
			ids = append(ids, id)
		}
		return ids
	case municipio.EdgeProvincia:
		if id := m.provincia; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MunicipioMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedschools != nil {
		edges = append(edges, municipio.EdgeSchools)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MunicipioMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case municipio.EdgeSchools:
		ids := make([]ent.Value, 0, len(m.removedschools))
		for id := range m.removedschools {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MunicipioMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedschools {
		edges = append(edges, municipio.EdgeSchools)
	}
	if m.clearedprovincia {
		edges = append(edges, municipio.EdgeProvincia)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MunicipioMutation) EdgeCleared(name string) bool {
	switch name {
	case municipio.EdgeSchools:
		return m.clearedschools
	case municipio.EdgeProvincia:
		return m.clearedprovincia
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MunicipioMutation) ClearEdge(name string) error {
	switch name {
	case municipio.EdgeProvincia:
		m.ClearProvincia()
		return nil
	}
	return fmt.Errorf("unknown Municipio unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MunicipioMutation) ResetEdge(name string) error {
	switch name {
	case municipio.EdgeSchools:
		m.ResetSchools()
		return nil
	case municipio.EdgeProvincia:
		m.ResetProvincia()
		return nil
	}
	return fmt.Errorf("unknown Municipio edge %s", name)
}

// PeriodMutation represents an operation that mutates the Period nodes in the graph.
type PeriodMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	name                *string
	clearedFields       map[string]struct{}
	classPeriods        map[string]struct{}
	removedclassPeriods map[string]struct{}
	clearedclassPeriods bool
	year                *string
	clearedyear         bool
	done                bool
	oldValue            func(context.Context) (*Period, error)
	predicates          []predicate.Period
}

var _ ent.Mutation = (*PeriodMutation)(nil)

// periodOption allows management of the mutation configuration using functional options.
type periodOption func(*PeriodMutation)

// newPeriodMutation creates new mutation for the Period entity.
func newPeriodMutation(c config, op Op, opts ...periodOption) *PeriodMutation {
	m := &PeriodMutation{
		config:        c,
		op:            op,
		typ:           TypePeriod,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPeriodID sets the ID field of the mutation.
func withPeriodID(id string) periodOption {
	return func(m *PeriodMutation) {
		var (
			err   error
			once  sync.Once
			value *Period
		)
		m.oldValue = func(ctx context.Context) (*Period, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Period.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPeriod sets the old Period of the mutation.
func withPeriod(node *Period) periodOption {
	return func(m *PeriodMutation) {
		m.oldValue = func(context.Context) (*Period, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PeriodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PeriodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Period entities.
func (m *PeriodMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PeriodMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PeriodMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Period.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PeriodMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PeriodMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Period entity.
// If the Period object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PeriodMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PeriodMutation) ResetName() {
	m.name = nil
}

// AddClassPeriodIDs adds the "classPeriods" edge to the ClassPeriod entity by ids.
func (m *PeriodMutation) AddClassPeriodIDs(ids ...string) {
	if m.classPeriods == nil {
		m.classPeriods = make(map[string]struct{})
	}
	for i := range ids {
		m.classPeriods[ids[i]] = struct{}{}
	}
}

// ClearClassPeriods clears the "classPeriods" edge to the ClassPeriod entity.
func (m *PeriodMutation) ClearClassPeriods() {
	m.clearedclassPeriods = true
}

// ClassPeriodsCleared reports if the "classPeriods" edge to the ClassPeriod entity was cleared.
func (m *PeriodMutation) ClassPeriodsCleared() bool {
	return m.clearedclassPeriods
}

// RemoveClassPeriodIDs removes the "classPeriods" edge to the ClassPeriod entity by IDs.
func (m *PeriodMutation) RemoveClassPeriodIDs(ids ...string) {
	if m.removedclassPeriods == nil {
		m.removedclassPeriods = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.classPeriods, ids[i])
		m.removedclassPeriods[ids[i]] = struct{}{}
	}
}

// RemovedClassPeriods returns the removed IDs of the "classPeriods" edge to the ClassPeriod entity.
func (m *PeriodMutation) RemovedClassPeriodsIDs() (ids []string) {
	for id := range m.removedclassPeriods {
		ids = append(ids, id)
	}
	return
}

// ClassPeriodsIDs returns the "classPeriods" edge IDs in the mutation.
func (m *PeriodMutation) ClassPeriodsIDs() (ids []string) {
	for id := range m.classPeriods {
		ids = append(ids, id)
	}
	return
}

// ResetClassPeriods resets all changes to the "classPeriods" edge.
func (m *PeriodMutation) ResetClassPeriods() {
	m.classPeriods = nil
	m.clearedclassPeriods = false
	m.removedclassPeriods = nil
}

// SetYearID sets the "year" edge to the Year entity by id.
func (m *PeriodMutation) SetYearID(id string) {
	m.year = &id
}

// ClearYear clears the "year" edge to the Year entity.
func (m *PeriodMutation) ClearYear() {
	m.clearedyear = true
}

// YearCleared reports if the "year" edge to the Year entity was cleared.
func (m *PeriodMutation) YearCleared() bool {
	return m.clearedyear
}

// YearID returns the "year" edge ID in the mutation.
func (m *PeriodMutation) YearID() (id string, exists bool) {
	if m.year != nil {
		return *m.year, true
	}
	return
}

// YearIDs returns the "year" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// YearID instead. It exists only for internal usage by the builders.
func (m *PeriodMutation) YearIDs() (ids []string) {
	if id := m.year; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetYear resets all changes to the "year" edge.
func (m *PeriodMutation) ResetYear() {
	m.year = nil
	m.clearedyear = false
}

// Where appends a list predicates to the PeriodMutation builder.
func (m *PeriodMutation) Where(ps ...predicate.Period) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PeriodMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Period).
func (m *PeriodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PeriodMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, period.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PeriodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case period.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PeriodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case period.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Period field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PeriodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case period.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Period field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PeriodMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PeriodMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PeriodMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Period numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PeriodMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PeriodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PeriodMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Period nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PeriodMutation) ResetField(name string) error {
	switch name {
	case period.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Period field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PeriodMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.classPeriods != nil {
		edges = append(edges, period.EdgeClassPeriods)
	}
	if m.year != nil {
		edges = append(edges, period.EdgeYear)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PeriodMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case period.EdgeClassPeriods:
		ids := make([]ent.Value, 0, len(m.classPeriods))
		for id := range m.classPeriods {
			ids = append(ids, id)
		}
		return ids
	case period.EdgeYear:
		if id := m.year; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PeriodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedclassPeriods != nil {
		edges = append(edges, period.EdgeClassPeriods)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PeriodMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case period.EdgeClassPeriods:
		ids := make([]ent.Value, 0, len(m.removedclassPeriods))
		for id := range m.removedclassPeriods {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PeriodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedclassPeriods {
		edges = append(edges, period.EdgeClassPeriods)
	}
	if m.clearedyear {
		edges = append(edges, period.EdgeYear)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PeriodMutation) EdgeCleared(name string) bool {
	switch name {
	case period.EdgeClassPeriods:
		return m.clearedclassPeriods
	case period.EdgeYear:
		return m.clearedyear
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PeriodMutation) ClearEdge(name string) error {
	switch name {
	case period.EdgeYear:
		m.ClearYear()
		return nil
	}
	return fmt.Errorf("unknown Period unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PeriodMutation) ResetEdge(name string) error {
	switch name {
	case period.EdgeClassPeriods:
		m.ResetClassPeriods()
		return nil
	case period.EdgeYear:
		m.ResetYear()
		return nil
	}
	return fmt.Errorf("unknown Period edge %s", name)
}

// ProvinciaMutation represents an operation that mutates the Provincia nodes in the graph.
type ProvinciaMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	name                *string
	clearedFields       map[string]struct{}
	municipios          map[string]struct{}
	removedmunicipios   map[string]struct{}
	clearedmunicipios   bool
	departamento        *string
	cleareddepartamento bool
	done                bool
	oldValue            func(context.Context) (*Provincia, error)
	predicates          []predicate.Provincia
}

var _ ent.Mutation = (*ProvinciaMutation)(nil)

// provinciaOption allows management of the mutation configuration using functional options.
type provinciaOption func(*ProvinciaMutation)

// newProvinciaMutation creates new mutation for the Provincia entity.
func newProvinciaMutation(c config, op Op, opts ...provinciaOption) *ProvinciaMutation {
	m := &ProvinciaMutation{
		config:        c,
		op:            op,
		typ:           TypeProvincia,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvinciaID sets the ID field of the mutation.
func withProvinciaID(id string) provinciaOption {
	return func(m *ProvinciaMutation) {
		var (
			err   error
			once  sync.Once
			value *Provincia
		)
		m.oldValue = func(ctx context.Context) (*Provincia, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Provincia.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvincia sets the old Provincia of the mutation.
func withProvincia(node *Provincia) provinciaOption {
	return func(m *ProvinciaMutation) {
		m.oldValue = func(context.Context) (*Provincia, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvinciaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvinciaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Provincia entities.
func (m *ProvinciaMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProvinciaMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProvinciaMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Provincia.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProvinciaMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProvinciaMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Provincia entity.
// If the Provincia object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinciaMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProvinciaMutation) ResetName() {
	m.name = nil
}

// AddMunicipioIDs adds the "municipios" edge to the Municipio entity by ids.
func (m *ProvinciaMutation) AddMunicipioIDs(ids ...string) {
	if m.municipios == nil {
		m.municipios = make(map[string]struct{})
	}
	for i := range ids {
		m.municipios[ids[i]] = struct{}{}
	}
}

// ClearMunicipios clears the "municipios" edge to the Municipio entity.
func (m *ProvinciaMutation) ClearMunicipios() {
	m.clearedmunicipios = true
}

// MunicipiosCleared reports if the "municipios" edge to the Municipio entity was cleared.
func (m *ProvinciaMutation) MunicipiosCleared() bool {
	return m.clearedmunicipios
}

// RemoveMunicipioIDs removes the "municipios" edge to the Municipio entity by IDs.
func (m *ProvinciaMutation) RemoveMunicipioIDs(ids ...string) {
	if m.removedmunicipios == nil {
		m.removedmunicipios = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.municipios, ids[i])
		m.removedmunicipios[ids[i]] = struct{}{}
	}
}

// RemovedMunicipios returns the removed IDs of the "municipios" edge to the Municipio entity.
func (m *ProvinciaMutation) RemovedMunicipiosIDs() (ids []string) {
	for id := range m.removedmunicipios {
		ids = append(ids, id)
	}
	return
}

// MunicipiosIDs returns the "municipios" edge IDs in the mutation.
func (m *ProvinciaMutation) MunicipiosIDs() (ids []string) {
	for id := range m.municipios {
		ids = append(ids, id)
	}
	return
}

// ResetMunicipios resets all changes to the "municipios" edge.
func (m *ProvinciaMutation) ResetMunicipios() {
	m.municipios = nil
	m.clearedmunicipios = false
	m.removedmunicipios = nil
}

// SetDepartamentoID sets the "departamento" edge to the Dpto entity by id.
func (m *ProvinciaMutation) SetDepartamentoID(id string) {
	m.departamento = &id
}

// ClearDepartamento clears the "departamento" edge to the Dpto entity.
func (m *ProvinciaMutation) ClearDepartamento() {
	m.cleareddepartamento = true
}

// DepartamentoCleared reports if the "departamento" edge to the Dpto entity was cleared.
func (m *ProvinciaMutation) DepartamentoCleared() bool {
	return m.cleareddepartamento
}

// DepartamentoID returns the "departamento" edge ID in the mutation.
func (m *ProvinciaMutation) DepartamentoID() (id string, exists bool) {
	if m.departamento != nil {
		return *m.departamento, true
	}
	return
}

// DepartamentoIDs returns the "departamento" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartamentoID instead. It exists only for internal usage by the builders.
func (m *ProvinciaMutation) DepartamentoIDs() (ids []string) {
	if id := m.departamento; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartamento resets all changes to the "departamento" edge.
func (m *ProvinciaMutation) ResetDepartamento() {
	m.departamento = nil
	m.cleareddepartamento = false
}

// Where appends a list predicates to the ProvinciaMutation builder.
func (m *ProvinciaMutation) Where(ps ...predicate.Provincia) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProvinciaMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Provincia).
func (m *ProvinciaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProvinciaMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, provincia.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProvinciaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provincia.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProvinciaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provincia.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Provincia field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvinciaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provincia.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Provincia field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProvinciaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProvinciaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvinciaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Provincia numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProvinciaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProvinciaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvinciaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Provincia nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProvinciaMutation) ResetField(name string) error {
	switch name {
	case provincia.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Provincia field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProvinciaMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.municipios != nil {
		edges = append(edges, provincia.EdgeMunicipios)
	}
	if m.departamento != nil {
		edges = append(edges, provincia.EdgeDepartamento)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProvinciaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provincia.EdgeMunicipios:
		ids := make([]ent.Value, 0, len(m.municipios))
		for id := range m.municipios {
			ids = append(ids, id)
		}
		return ids
	case provincia.EdgeDepartamento:
		if id := m.departamento; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProvinciaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmunicipios != nil {
		edges = append(edges, provincia.EdgeMunicipios)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProvinciaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provincia.EdgeMunicipios:
		ids := make([]ent.Value, 0, len(m.removedmunicipios))
		for id := range m.removedmunicipios {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProvinciaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmunicipios {
		edges = append(edges, provincia.EdgeMunicipios)
	}
	if m.cleareddepartamento {
		edges = append(edges, provincia.EdgeDepartamento)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProvinciaMutation) EdgeCleared(name string) bool {
	switch name {
	case provincia.EdgeMunicipios:
		return m.clearedmunicipios
	case provincia.EdgeDepartamento:
		return m.cleareddepartamento
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProvinciaMutation) ClearEdge(name string) error {
	switch name {
	case provincia.EdgeDepartamento:
		m.ClearDepartamento()
		return nil
	}
	return fmt.Errorf("unknown Provincia unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProvinciaMutation) ResetEdge(name string) error {
	switch name {
	case provincia.EdgeMunicipios:
		m.ResetMunicipios()
		return nil
	case provincia.EdgeDepartamento:
		m.ResetDepartamento()
		return nil
	}
	return fmt.Errorf("unknown Provincia edge %s", name)
}

// SchoolMutation represents an operation that mutates the School nodes in the graph.
type SchoolMutation struct {
	config
	op               Op
	typ              string
	id               *string
	name             *string
	lat              *string
	lon              *string
	clearedFields    map[string]struct{}
	classes          map[string]struct{}
	removedclasses   map[string]struct{}
	clearedclasses   bool
	municipio        *string
	clearedmunicipio bool
	done             bool
	oldValue         func(context.Context) (*School, error)
	predicates       []predicate.School
}

var _ ent.Mutation = (*SchoolMutation)(nil)

// schoolOption allows management of the mutation configuration using functional options.
type schoolOption func(*SchoolMutation)

// newSchoolMutation creates new mutation for the School entity.
func newSchoolMutation(c config, op Op, opts ...schoolOption) *SchoolMutation {
	m := &SchoolMutation{
		config:        c,
		op:            op,
		typ:           TypeSchool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchoolID sets the ID field of the mutation.
func withSchoolID(id string) schoolOption {
	return func(m *SchoolMutation) {
		var (
			err   error
			once  sync.Once
			value *School
		)
		m.oldValue = func(ctx context.Context) (*School, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().School.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchool sets the old School of the mutation.
func withSchool(node *School) schoolOption {
	return func(m *SchoolMutation) {
		m.oldValue = func(context.Context) (*School, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchoolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchoolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of School entities.
func (m *SchoolMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SchoolMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SchoolMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().School.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SchoolMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SchoolMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SchoolMutation) ResetName() {
	m.name = nil
}

// SetLat sets the "lat" field.
func (m *SchoolMutation) SetLat(s string) {
	m.lat = &s
}

// Lat returns the value of the "lat" field in the mutation.
func (m *SchoolMutation) Lat() (r string, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldLat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// ResetLat resets all changes to the "lat" field.
func (m *SchoolMutation) ResetLat() {
	m.lat = nil
}

// SetLon sets the "lon" field.
func (m *SchoolMutation) SetLon(s string) {
	m.lon = &s
}

// Lon returns the value of the "lon" field in the mutation.
func (m *SchoolMutation) Lon() (r string, exists bool) {
	v := m.lon
	if v == nil {
		return
	}
	return *v, true
}

// OldLon returns the old "lon" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldLon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLon: %w", err)
	}
	return oldValue.Lon, nil
}

// ResetLon resets all changes to the "lon" field.
func (m *SchoolMutation) ResetLon() {
	m.lon = nil
}

// AddClassIDs adds the "classes" edge to the Class entity by ids.
func (m *SchoolMutation) AddClassIDs(ids ...string) {
	if m.classes == nil {
		m.classes = make(map[string]struct{})
	}
	for i := range ids {
		m.classes[ids[i]] = struct{}{}
	}
}

// ClearClasses clears the "classes" edge to the Class entity.
func (m *SchoolMutation) ClearClasses() {
	m.clearedclasses = true
}

// ClassesCleared reports if the "classes" edge to the Class entity was cleared.
func (m *SchoolMutation) ClassesCleared() bool {
	return m.clearedclasses
}

// RemoveClassIDs removes the "classes" edge to the Class entity by IDs.
func (m *SchoolMutation) RemoveClassIDs(ids ...string) {
	if m.removedclasses == nil {
		m.removedclasses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.classes, ids[i])
		m.removedclasses[ids[i]] = struct{}{}
	}
}

// RemovedClasses returns the removed IDs of the "classes" edge to the Class entity.
func (m *SchoolMutation) RemovedClassesIDs() (ids []string) {
	for id := range m.removedclasses {
		ids = append(ids, id)
	}
	return
}

// ClassesIDs returns the "classes" edge IDs in the mutation.
func (m *SchoolMutation) ClassesIDs() (ids []string) {
	for id := range m.classes {
		ids = append(ids, id)
	}
	return
}

// ResetClasses resets all changes to the "classes" edge.
func (m *SchoolMutation) ResetClasses() {
	m.classes = nil
	m.clearedclasses = false
	m.removedclasses = nil
}

// SetMunicipioID sets the "municipio" edge to the Municipio entity by id.
func (m *SchoolMutation) SetMunicipioID(id string) {
	m.municipio = &id
}

// ClearMunicipio clears the "municipio" edge to the Municipio entity.
func (m *SchoolMutation) ClearMunicipio() {
	m.clearedmunicipio = true
}

// MunicipioCleared reports if the "municipio" edge to the Municipio entity was cleared.
func (m *SchoolMutation) MunicipioCleared() bool {
	return m.clearedmunicipio
}

// MunicipioID returns the "municipio" edge ID in the mutation.
func (m *SchoolMutation) MunicipioID() (id string, exists bool) {
	if m.municipio != nil {
		return *m.municipio, true
	}
	return
}

// MunicipioIDs returns the "municipio" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MunicipioID instead. It exists only for internal usage by the builders.
func (m *SchoolMutation) MunicipioIDs() (ids []string) {
	if id := m.municipio; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMunicipio resets all changes to the "municipio" edge.
func (m *SchoolMutation) ResetMunicipio() {
	m.municipio = nil
	m.clearedmunicipio = false
}

// Where appends a list predicates to the SchoolMutation builder.
func (m *SchoolMutation) Where(ps ...predicate.School) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SchoolMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (School).
func (m *SchoolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SchoolMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, school.FieldName)
	}
	if m.lat != nil {
		fields = append(fields, school.FieldLat)
	}
	if m.lon != nil {
		fields = append(fields, school.FieldLon)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SchoolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case school.FieldName:
		return m.Name()
	case school.FieldLat:
		return m.Lat()
	case school.FieldLon:
		return m.Lon()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SchoolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case school.FieldName:
		return m.OldName(ctx)
	case school.FieldLat:
		return m.OldLat(ctx)
	case school.FieldLon:
		return m.OldLon(ctx)
	}
	return nil, fmt.Errorf("unknown School field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchoolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case school.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case school.FieldLat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case school.FieldLon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLon(v)
		return nil
	}
	return fmt.Errorf("unknown School field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SchoolMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SchoolMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchoolMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown School numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SchoolMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SchoolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchoolMutation) ClearField(name string) error {
	return fmt.Errorf("unknown School nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SchoolMutation) ResetField(name string) error {
	switch name {
	case school.FieldName:
		m.ResetName()
		return nil
	case school.FieldLat:
		m.ResetLat()
		return nil
	case school.FieldLon:
		m.ResetLon()
		return nil
	}
	return fmt.Errorf("unknown School field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SchoolMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.classes != nil {
		edges = append(edges, school.EdgeClasses)
	}
	if m.municipio != nil {
		edges = append(edges, school.EdgeMunicipio)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SchoolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case school.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.classes))
		for id := range m.classes {
			ids = append(ids, id)
		}
		return ids
	case school.EdgeMunicipio:
		if id := m.municipio; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SchoolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedclasses != nil {
		edges = append(edges, school.EdgeClasses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SchoolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case school.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.removedclasses))
		for id := range m.removedclasses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SchoolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedclasses {
		edges = append(edges, school.EdgeClasses)
	}
	if m.clearedmunicipio {
		edges = append(edges, school.EdgeMunicipio)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SchoolMutation) EdgeCleared(name string) bool {
	switch name {
	case school.EdgeClasses:
		return m.clearedclasses
	case school.EdgeMunicipio:
		return m.clearedmunicipio
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SchoolMutation) ClearEdge(name string) error {
	switch name {
	case school.EdgeMunicipio:
		m.ClearMunicipio()
		return nil
	}
	return fmt.Errorf("unknown School unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SchoolMutation) ResetEdge(name string) error {
	switch name {
	case school.EdgeClasses:
		m.ResetClasses()
		return nil
	case school.EdgeMunicipio:
		m.ResetMunicipio()
		return nil
	}
	return fmt.Errorf("unknown School edge %s", name)
}

// ScoreMutation represents an operation that mutates the Score nodes in the graph.
type ScoreMutation struct {
	config
	op              Op
	typ             string
	id              *string
	points          *int
	addpoints       *int
	clearedFields   map[string]struct{}
	activity        *string
	clearedactivity bool
	student         *string
	clearedstudent  bool
	done            bool
	oldValue        func(context.Context) (*Score, error)
	predicates      []predicate.Score
}

var _ ent.Mutation = (*ScoreMutation)(nil)

// scoreOption allows management of the mutation configuration using functional options.
type scoreOption func(*ScoreMutation)

// newScoreMutation creates new mutation for the Score entity.
func newScoreMutation(c config, op Op, opts ...scoreOption) *ScoreMutation {
	m := &ScoreMutation{
		config:        c,
		op:            op,
		typ:           TypeScore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScoreID sets the ID field of the mutation.
func withScoreID(id string) scoreOption {
	return func(m *ScoreMutation) {
		var (
			err   error
			once  sync.Once
			value *Score
		)
		m.oldValue = func(ctx context.Context) (*Score, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Score.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScore sets the old Score of the mutation.
func withScore(node *Score) scoreOption {
	return func(m *ScoreMutation) {
		m.oldValue = func(context.Context) (*Score, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Score entities.
func (m *ScoreMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScoreMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScoreMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Score.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPoints sets the "points" field.
func (m *ScoreMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *ScoreMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the Score entity.
// If the Score object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *ScoreMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *ScoreMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *ScoreMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetActivityID sets the "activity" edge to the Activity entity by id.
func (m *ScoreMutation) SetActivityID(id string) {
	m.activity = &id
}

// ClearActivity clears the "activity" edge to the Activity entity.
func (m *ScoreMutation) ClearActivity() {
	m.clearedactivity = true
}

// ActivityCleared reports if the "activity" edge to the Activity entity was cleared.
func (m *ScoreMutation) ActivityCleared() bool {
	return m.clearedactivity
}

// ActivityID returns the "activity" edge ID in the mutation.
func (m *ScoreMutation) ActivityID() (id string, exists bool) {
	if m.activity != nil {
		return *m.activity, true
	}
	return
}

// ActivityIDs returns the "activity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityID instead. It exists only for internal usage by the builders.
func (m *ScoreMutation) ActivityIDs() (ids []string) {
	if id := m.activity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivity resets all changes to the "activity" edge.
func (m *ScoreMutation) ResetActivity() {
	m.activity = nil
	m.clearedactivity = false
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *ScoreMutation) SetStudentID(id string) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *ScoreMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *ScoreMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *ScoreMutation) StudentID() (id string, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *ScoreMutation) StudentIDs() (ids []string) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *ScoreMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// Where appends a list predicates to the ScoreMutation builder.
func (m *ScoreMutation) Where(ps ...predicate.Score) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ScoreMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Score).
func (m *ScoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScoreMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.points != nil {
		fields = append(fields, score.FieldPoints)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case score.FieldPoints:
		return m.Points()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case score.FieldPoints:
		return m.OldPoints(ctx)
	}
	return nil, fmt.Errorf("unknown Score field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case score.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	}
	return fmt.Errorf("unknown Score field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScoreMutation) AddedFields() []string {
	var fields []string
	if m.addpoints != nil {
		fields = append(fields, score.FieldPoints)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScoreMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case score.FieldPoints:
		return m.AddedPoints()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	case score.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	}
	return fmt.Errorf("unknown Score numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScoreMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScoreMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Score nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScoreMutation) ResetField(name string) error {
	switch name {
	case score.FieldPoints:
		m.ResetPoints()
		return nil
	}
	return fmt.Errorf("unknown Score field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.activity != nil {
		edges = append(edges, score.EdgeActivity)
	}
	if m.student != nil {
		edges = append(edges, score.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case score.EdgeActivity:
		if id := m.activity; id != nil {
			return []ent.Value{*id}
		}
	case score.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScoreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedactivity {
		edges = append(edges, score.EdgeActivity)
	}
	if m.clearedstudent {
		edges = append(edges, score.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScoreMutation) EdgeCleared(name string) bool {
	switch name {
	case score.EdgeActivity:
		return m.clearedactivity
	case score.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScoreMutation) ClearEdge(name string) error {
	switch name {
	case score.EdgeActivity:
		m.ClearActivity()
		return nil
	case score.EdgeStudent:
		m.ClearStudent()
		return nil
	}
	return fmt.Errorf("unknown Score unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScoreMutation) ResetEdge(name string) error {
	switch name {
	case score.EdgeActivity:
		m.ResetActivity()
		return nil
	case score.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown Score edge %s", name)
}

// ScoreSyncMutation represents an operation that mutates the ScoreSync nodes in the graph.
type ScoreSyncMutation struct {
	config
	op              Op
	typ             string
	id              *string
	last_sync_id    *string
	clearedFields   map[string]struct{}
	activity        *string
	clearedactivity bool
	done            bool
	oldValue        func(context.Context) (*ScoreSync, error)
	predicates      []predicate.ScoreSync
}

var _ ent.Mutation = (*ScoreSyncMutation)(nil)

// scoresyncOption allows management of the mutation configuration using functional options.
type scoresyncOption func(*ScoreSyncMutation)

// newScoreSyncMutation creates new mutation for the ScoreSync entity.
func newScoreSyncMutation(c config, op Op, opts ...scoresyncOption) *ScoreSyncMutation {
	m := &ScoreSyncMutation{
		config:        c,
		op:            op,
		typ:           TypeScoreSync,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScoreSyncID sets the ID field of the mutation.
func withScoreSyncID(id string) scoresyncOption {
	return func(m *ScoreSyncMutation) {
		var (
			err   error
			once  sync.Once
			value *ScoreSync
		)
		m.oldValue = func(ctx context.Context) (*ScoreSync, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScoreSync.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScoreSync sets the old ScoreSync of the mutation.
func withScoreSync(node *ScoreSync) scoresyncOption {
	return func(m *ScoreSyncMutation) {
		m.oldValue = func(context.Context) (*ScoreSync, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScoreSyncMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScoreSyncMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScoreSync entities.
func (m *ScoreSyncMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScoreSyncMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScoreSyncMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScoreSync.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLastSyncID sets the "last_sync_id" field.
func (m *ScoreSyncMutation) SetLastSyncID(s string) {
	m.last_sync_id = &s
}

// LastSyncID returns the value of the "last_sync_id" field in the mutation.
func (m *ScoreSyncMutation) LastSyncID() (r string, exists bool) {
	v := m.last_sync_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSyncID returns the old "last_sync_id" field's value of the ScoreSync entity.
// If the ScoreSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreSyncMutation) OldLastSyncID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSyncID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSyncID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSyncID: %w", err)
	}
	return oldValue.LastSyncID, nil
}

// ResetLastSyncID resets all changes to the "last_sync_id" field.
func (m *ScoreSyncMutation) ResetLastSyncID() {
	m.last_sync_id = nil
}

// SetActivityID sets the "activity" edge to the Activity entity by id.
func (m *ScoreSyncMutation) SetActivityID(id string) {
	m.activity = &id
}

// ClearActivity clears the "activity" edge to the Activity entity.
func (m *ScoreSyncMutation) ClearActivity() {
	m.clearedactivity = true
}

// ActivityCleared reports if the "activity" edge to the Activity entity was cleared.
func (m *ScoreSyncMutation) ActivityCleared() bool {
	return m.clearedactivity
}

// ActivityID returns the "activity" edge ID in the mutation.
func (m *ScoreSyncMutation) ActivityID() (id string, exists bool) {
	if m.activity != nil {
		return *m.activity, true
	}
	return
}

// ActivityIDs returns the "activity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityID instead. It exists only for internal usage by the builders.
func (m *ScoreSyncMutation) ActivityIDs() (ids []string) {
	if id := m.activity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivity resets all changes to the "activity" edge.
func (m *ScoreSyncMutation) ResetActivity() {
	m.activity = nil
	m.clearedactivity = false
}

// Where appends a list predicates to the ScoreSyncMutation builder.
func (m *ScoreSyncMutation) Where(ps ...predicate.ScoreSync) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ScoreSyncMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ScoreSync).
func (m *ScoreSyncMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScoreSyncMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.last_sync_id != nil {
		fields = append(fields, scoresync.FieldLastSyncID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScoreSyncMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scoresync.FieldLastSyncID:
		return m.LastSyncID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScoreSyncMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scoresync.FieldLastSyncID:
		return m.OldLastSyncID(ctx)
	}
	return nil, fmt.Errorf("unknown ScoreSync field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScoreSyncMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scoresync.FieldLastSyncID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSyncID(v)
		return nil
	}
	return fmt.Errorf("unknown ScoreSync field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScoreSyncMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScoreSyncMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScoreSyncMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ScoreSync numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScoreSyncMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScoreSyncMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScoreSyncMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ScoreSync nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScoreSyncMutation) ResetField(name string) error {
	switch name {
	case scoresync.FieldLastSyncID:
		m.ResetLastSyncID()
		return nil
	}
	return fmt.Errorf("unknown ScoreSync field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScoreSyncMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.activity != nil {
		edges = append(edges, scoresync.EdgeActivity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScoreSyncMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scoresync.EdgeActivity:
		if id := m.activity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScoreSyncMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScoreSyncMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScoreSyncMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedactivity {
		edges = append(edges, scoresync.EdgeActivity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScoreSyncMutation) EdgeCleared(name string) bool {
	switch name {
	case scoresync.EdgeActivity:
		return m.clearedactivity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScoreSyncMutation) ClearEdge(name string) error {
	switch name {
	case scoresync.EdgeActivity:
		m.ClearActivity()
		return nil
	}
	return fmt.Errorf("unknown ScoreSync unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScoreSyncMutation) ResetEdge(name string) error {
	switch name {
	case scoresync.EdgeActivity:
		m.ResetActivity()
		return nil
	}
	return fmt.Errorf("unknown ScoreSync edge %s", name)
}

// StudentMutation represents an operation that mutates the Student nodes in the graph.
type StudentMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	name               *string
	last_name          *string
	ci                 *string
	clearedFields      map[string]struct{}
	attendances        map[string]struct{}
	removedattendances map[string]struct{}
	clearedattendances bool
	scores             map[string]struct{}
	removedscores      map[string]struct{}
	clearedscores      bool
	class              *string
	clearedclass       bool
	done               bool
	oldValue           func(context.Context) (*Student, error)
	predicates         []predicate.Student
}

var _ ent.Mutation = (*StudentMutation)(nil)

// studentOption allows management of the mutation configuration using functional options.
type studentOption func(*StudentMutation)

// newStudentMutation creates new mutation for the Student entity.
func newStudentMutation(c config, op Op, opts ...studentOption) *StudentMutation {
	m := &StudentMutation{
		config:        c,
		op:            op,
		typ:           TypeStudent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudentID sets the ID field of the mutation.
func withStudentID(id string) studentOption {
	return func(m *StudentMutation) {
		var (
			err   error
			once  sync.Once
			value *Student
		)
		m.oldValue = func(ctx context.Context) (*Student, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Student.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudent sets the old Student of the mutation.
func withStudent(node *Student) studentOption {
	return func(m *StudentMutation) {
		m.oldValue = func(context.Context) (*Student, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Student entities.
func (m *StudentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StudentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StudentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Student.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *StudentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StudentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StudentMutation) ResetName() {
	m.name = nil
}

// SetLastName sets the "last_name" field.
func (m *StudentMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *StudentMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *StudentMutation) ResetLastName() {
	m.last_name = nil
}

// SetCi sets the "ci" field.
func (m *StudentMutation) SetCi(s string) {
	m.ci = &s
}

// Ci returns the value of the "ci" field in the mutation.
func (m *StudentMutation) Ci() (r string, exists bool) {
	v := m.ci
	if v == nil {
		return
	}
	return *v, true
}

// OldCi returns the old "ci" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldCi(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCi: %w", err)
	}
	return oldValue.Ci, nil
}

// ResetCi resets all changes to the "ci" field.
func (m *StudentMutation) ResetCi() {
	m.ci = nil
}

// AddAttendanceIDs adds the "attendances" edge to the Attendance entity by ids.
func (m *StudentMutation) AddAttendanceIDs(ids ...string) {
	if m.attendances == nil {
		m.attendances = make(map[string]struct{})
	}
	for i := range ids {
		m.attendances[ids[i]] = struct{}{}
	}
}

// ClearAttendances clears the "attendances" edge to the Attendance entity.
func (m *StudentMutation) ClearAttendances() {
	m.clearedattendances = true
}

// AttendancesCleared reports if the "attendances" edge to the Attendance entity was cleared.
func (m *StudentMutation) AttendancesCleared() bool {
	return m.clearedattendances
}

// RemoveAttendanceIDs removes the "attendances" edge to the Attendance entity by IDs.
func (m *StudentMutation) RemoveAttendanceIDs(ids ...string) {
	if m.removedattendances == nil {
		m.removedattendances = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.attendances, ids[i])
		m.removedattendances[ids[i]] = struct{}{}
	}
}

// RemovedAttendances returns the removed IDs of the "attendances" edge to the Attendance entity.
func (m *StudentMutation) RemovedAttendancesIDs() (ids []string) {
	for id := range m.removedattendances {
		ids = append(ids, id)
	}
	return
}

// AttendancesIDs returns the "attendances" edge IDs in the mutation.
func (m *StudentMutation) AttendancesIDs() (ids []string) {
	for id := range m.attendances {
		ids = append(ids, id)
	}
	return
}

// ResetAttendances resets all changes to the "attendances" edge.
func (m *StudentMutation) ResetAttendances() {
	m.attendances = nil
	m.clearedattendances = false
	m.removedattendances = nil
}

// AddScoreIDs adds the "scores" edge to the Score entity by ids.
func (m *StudentMutation) AddScoreIDs(ids ...string) {
	if m.scores == nil {
		m.scores = make(map[string]struct{})
	}
	for i := range ids {
		m.scores[ids[i]] = struct{}{}
	}
}

// ClearScores clears the "scores" edge to the Score entity.
func (m *StudentMutation) ClearScores() {
	m.clearedscores = true
}

// ScoresCleared reports if the "scores" edge to the Score entity was cleared.
func (m *StudentMutation) ScoresCleared() bool {
	return m.clearedscores
}

// RemoveScoreIDs removes the "scores" edge to the Score entity by IDs.
func (m *StudentMutation) RemoveScoreIDs(ids ...string) {
	if m.removedscores == nil {
		m.removedscores = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.scores, ids[i])
		m.removedscores[ids[i]] = struct{}{}
	}
}

// RemovedScores returns the removed IDs of the "scores" edge to the Score entity.
func (m *StudentMutation) RemovedScoresIDs() (ids []string) {
	for id := range m.removedscores {
		ids = append(ids, id)
	}
	return
}

// ScoresIDs returns the "scores" edge IDs in the mutation.
func (m *StudentMutation) ScoresIDs() (ids []string) {
	for id := range m.scores {
		ids = append(ids, id)
	}
	return
}

// ResetScores resets all changes to the "scores" edge.
func (m *StudentMutation) ResetScores() {
	m.scores = nil
	m.clearedscores = false
	m.removedscores = nil
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *StudentMutation) SetClassID(id string) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *StudentMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *StudentMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *StudentMutation) ClassID() (id string, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) ClassIDs() (ids []string) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *StudentMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// Where appends a list predicates to the StudentMutation builder.
func (m *StudentMutation) Where(ps ...predicate.Student) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StudentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Student).
func (m *StudentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StudentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, student.FieldName)
	}
	if m.last_name != nil {
		fields = append(fields, student.FieldLastName)
	}
	if m.ci != nil {
		fields = append(fields, student.FieldCi)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StudentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case student.FieldName:
		return m.Name()
	case student.FieldLastName:
		return m.LastName()
	case student.FieldCi:
		return m.Ci()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StudentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case student.FieldName:
		return m.OldName(ctx)
	case student.FieldLastName:
		return m.OldLastName(ctx)
	case student.FieldCi:
		return m.OldCi(ctx)
	}
	return nil, fmt.Errorf("unknown Student field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case student.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case student.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case student.FieldCi:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCi(v)
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StudentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StudentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Student numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StudentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StudentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Student nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StudentMutation) ResetField(name string) error {
	switch name {
	case student.FieldName:
		m.ResetName()
		return nil
	case student.FieldLastName:
		m.ResetLastName()
		return nil
	case student.FieldCi:
		m.ResetCi()
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StudentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.attendances != nil {
		edges = append(edges, student.EdgeAttendances)
	}
	if m.scores != nil {
		edges = append(edges, student.EdgeScores)
	}
	if m.class != nil {
		edges = append(edges, student.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StudentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeAttendances:
		ids := make([]ent.Value, 0, len(m.attendances))
		for id := range m.attendances {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeScores:
		ids := make([]ent.Value, 0, len(m.scores))
		for id := range m.scores {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StudentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedattendances != nil {
		edges = append(edges, student.EdgeAttendances)
	}
	if m.removedscores != nil {
		edges = append(edges, student.EdgeScores)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StudentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeAttendances:
		ids := make([]ent.Value, 0, len(m.removedattendances))
		for id := range m.removedattendances {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeScores:
		ids := make([]ent.Value, 0, len(m.removedscores))
		for id := range m.removedscores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StudentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedattendances {
		edges = append(edges, student.EdgeAttendances)
	}
	if m.clearedscores {
		edges = append(edges, student.EdgeScores)
	}
	if m.clearedclass {
		edges = append(edges, student.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StudentMutation) EdgeCleared(name string) bool {
	switch name {
	case student.EdgeAttendances:
		return m.clearedattendances
	case student.EdgeScores:
		return m.clearedscores
	case student.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StudentMutation) ClearEdge(name string) error {
	switch name {
	case student.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown Student unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StudentMutation) ResetEdge(name string) error {
	switch name {
	case student.EdgeAttendances:
		m.ResetAttendances()
		return nil
	case student.EdgeScores:
		m.ResetScores()
		return nil
	case student.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown Student edge %s", name)
}

// StudentSyncMutation represents an operation that mutates the StudentSync nodes in the graph.
type StudentSyncMutation struct {
	config
	op            Op
	typ           string
	id            *string
	last_sync_id  *string
	clearedFields map[string]struct{}
	class         *string
	clearedclass  bool
	done          bool
	oldValue      func(context.Context) (*StudentSync, error)
	predicates    []predicate.StudentSync
}

var _ ent.Mutation = (*StudentSyncMutation)(nil)

// studentsyncOption allows management of the mutation configuration using functional options.
type studentsyncOption func(*StudentSyncMutation)

// newStudentSyncMutation creates new mutation for the StudentSync entity.
func newStudentSyncMutation(c config, op Op, opts ...studentsyncOption) *StudentSyncMutation {
	m := &StudentSyncMutation{
		config:        c,
		op:            op,
		typ:           TypeStudentSync,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudentSyncID sets the ID field of the mutation.
func withStudentSyncID(id string) studentsyncOption {
	return func(m *StudentSyncMutation) {
		var (
			err   error
			once  sync.Once
			value *StudentSync
		)
		m.oldValue = func(ctx context.Context) (*StudentSync, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StudentSync.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudentSync sets the old StudentSync of the mutation.
func withStudentSync(node *StudentSync) studentsyncOption {
	return func(m *StudentSyncMutation) {
		m.oldValue = func(context.Context) (*StudentSync, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudentSyncMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudentSyncMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StudentSync entities.
func (m *StudentSyncMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StudentSyncMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StudentSyncMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StudentSync.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLastSyncID sets the "last_sync_id" field.
func (m *StudentSyncMutation) SetLastSyncID(s string) {
	m.last_sync_id = &s
}

// LastSyncID returns the value of the "last_sync_id" field in the mutation.
func (m *StudentSyncMutation) LastSyncID() (r string, exists bool) {
	v := m.last_sync_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSyncID returns the old "last_sync_id" field's value of the StudentSync entity.
// If the StudentSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentSyncMutation) OldLastSyncID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSyncID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSyncID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSyncID: %w", err)
	}
	return oldValue.LastSyncID, nil
}

// ResetLastSyncID resets all changes to the "last_sync_id" field.
func (m *StudentSyncMutation) ResetLastSyncID() {
	m.last_sync_id = nil
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *StudentSyncMutation) SetClassID(id string) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *StudentSyncMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *StudentSyncMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *StudentSyncMutation) ClassID() (id string, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *StudentSyncMutation) ClassIDs() (ids []string) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *StudentSyncMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// Where appends a list predicates to the StudentSyncMutation builder.
func (m *StudentSyncMutation) Where(ps ...predicate.StudentSync) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StudentSyncMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StudentSync).
func (m *StudentSyncMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StudentSyncMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.last_sync_id != nil {
		fields = append(fields, studentsync.FieldLastSyncID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StudentSyncMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case studentsync.FieldLastSyncID:
		return m.LastSyncID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StudentSyncMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case studentsync.FieldLastSyncID:
		return m.OldLastSyncID(ctx)
	}
	return nil, fmt.Errorf("unknown StudentSync field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentSyncMutation) SetField(name string, value ent.Value) error {
	switch name {
	case studentsync.FieldLastSyncID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSyncID(v)
		return nil
	}
	return fmt.Errorf("unknown StudentSync field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StudentSyncMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StudentSyncMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentSyncMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StudentSync numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StudentSyncMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StudentSyncMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudentSyncMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StudentSync nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StudentSyncMutation) ResetField(name string) error {
	switch name {
	case studentsync.FieldLastSyncID:
		m.ResetLastSyncID()
		return nil
	}
	return fmt.Errorf("unknown StudentSync field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StudentSyncMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.class != nil {
		edges = append(edges, studentsync.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StudentSyncMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case studentsync.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StudentSyncMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StudentSyncMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StudentSyncMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedclass {
		edges = append(edges, studentsync.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StudentSyncMutation) EdgeCleared(name string) bool {
	switch name {
	case studentsync.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StudentSyncMutation) ClearEdge(name string) error {
	switch name {
	case studentsync.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown StudentSync unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StudentSyncMutation) ResetEdge(name string) error {
	switch name {
	case studentsync.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown StudentSync edge %s", name)
}

// SubjectMutation represents an operation that mutates the Subject nodes in the graph.
type SubjectMutation struct {
	config
	op             Op
	typ            string
	id             *string
	name           *string
	clearedFields  map[string]struct{}
	classes        map[string]struct{}
	removedclasses map[string]struct{}
	clearedclasses bool
	done           bool
	oldValue       func(context.Context) (*Subject, error)
	predicates     []predicate.Subject
}

var _ ent.Mutation = (*SubjectMutation)(nil)

// subjectOption allows management of the mutation configuration using functional options.
type subjectOption func(*SubjectMutation)

// newSubjectMutation creates new mutation for the Subject entity.
func newSubjectMutation(c config, op Op, opts ...subjectOption) *SubjectMutation {
	m := &SubjectMutation{
		config:        c,
		op:            op,
		typ:           TypeSubject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectID sets the ID field of the mutation.
func withSubjectID(id string) subjectOption {
	return func(m *SubjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Subject
		)
		m.oldValue = func(ctx context.Context) (*Subject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubject sets the old Subject of the mutation.
func withSubject(node *Subject) subjectOption {
	return func(m *SubjectMutation) {
		m.oldValue = func(context.Context) (*Subject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subject entities.
func (m *SubjectMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubjectMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubjectMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SubjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubjectMutation) ResetName() {
	m.name = nil
}

// AddClassIDs adds the "classes" edge to the Class entity by ids.
func (m *SubjectMutation) AddClassIDs(ids ...string) {
	if m.classes == nil {
		m.classes = make(map[string]struct{})
	}
	for i := range ids {
		m.classes[ids[i]] = struct{}{}
	}
}

// ClearClasses clears the "classes" edge to the Class entity.
func (m *SubjectMutation) ClearClasses() {
	m.clearedclasses = true
}

// ClassesCleared reports if the "classes" edge to the Class entity was cleared.
func (m *SubjectMutation) ClassesCleared() bool {
	return m.clearedclasses
}

// RemoveClassIDs removes the "classes" edge to the Class entity by IDs.
func (m *SubjectMutation) RemoveClassIDs(ids ...string) {
	if m.removedclasses == nil {
		m.removedclasses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.classes, ids[i])
		m.removedclasses[ids[i]] = struct{}{}
	}
}

// RemovedClasses returns the removed IDs of the "classes" edge to the Class entity.
func (m *SubjectMutation) RemovedClassesIDs() (ids []string) {
	for id := range m.removedclasses {
		ids = append(ids, id)
	}
	return
}

// ClassesIDs returns the "classes" edge IDs in the mutation.
func (m *SubjectMutation) ClassesIDs() (ids []string) {
	for id := range m.classes {
		ids = append(ids, id)
	}
	return
}

// ResetClasses resets all changes to the "classes" edge.
func (m *SubjectMutation) ResetClasses() {
	m.classes = nil
	m.clearedclasses = false
	m.removedclasses = nil
}

// Where appends a list predicates to the SubjectMutation builder.
func (m *SubjectMutation) Where(ps ...predicate.Subject) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SubjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Subject).
func (m *SubjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubjectMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, subject.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subject.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subject.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Subject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subject.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Subject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubjectMutation) ResetField(name string) error {
	switch name {
	case subject.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.classes != nil {
		edges = append(edges, subject.EdgeClasses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.classes))
		for id := range m.classes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedclasses != nil {
		edges = append(edges, subject.EdgeClasses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.removedclasses))
		for id := range m.removedclasses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedclasses {
		edges = append(edges, subject.EdgeClasses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubjectMutation) EdgeCleared(name string) bool {
	switch name {
	case subject.EdgeClasses:
		return m.clearedclasses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubjectMutation) ResetEdge(name string) error {
	switch name {
	case subject.EdgeClasses:
		m.ResetClasses()
		return nil
	}
	return fmt.Errorf("unknown Subject edge %s", name)
}

// TeacherMutation represents an operation that mutates the Teacher nodes in the graph.
type TeacherMutation struct {
	config
	op             Op
	typ            string
	id             *string
	name           *string
	last_name      *string
	email          *string
	password       *string
	clearedFields  map[string]struct{}
	classes        map[string]struct{}
	removedclasses map[string]struct{}
	clearedclasses bool
	done           bool
	oldValue       func(context.Context) (*Teacher, error)
	predicates     []predicate.Teacher
}

var _ ent.Mutation = (*TeacherMutation)(nil)

// teacherOption allows management of the mutation configuration using functional options.
type teacherOption func(*TeacherMutation)

// newTeacherMutation creates new mutation for the Teacher entity.
func newTeacherMutation(c config, op Op, opts ...teacherOption) *TeacherMutation {
	m := &TeacherMutation{
		config:        c,
		op:            op,
		typ:           TypeTeacher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeacherID sets the ID field of the mutation.
func withTeacherID(id string) teacherOption {
	return func(m *TeacherMutation) {
		var (
			err   error
			once  sync.Once
			value *Teacher
		)
		m.oldValue = func(ctx context.Context) (*Teacher, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Teacher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeacher sets the old Teacher of the mutation.
func withTeacher(node *Teacher) teacherOption {
	return func(m *TeacherMutation) {
		m.oldValue = func(context.Context) (*Teacher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeacherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeacherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Teacher entities.
func (m *TeacherMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeacherMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeacherMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Teacher.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TeacherMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeacherMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeacherMutation) ResetName() {
	m.name = nil
}

// SetLastName sets the "last_name" field.
func (m *TeacherMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *TeacherMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *TeacherMutation) ResetLastName() {
	m.last_name = nil
}

// SetEmail sets the "email" field.
func (m *TeacherMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *TeacherMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *TeacherMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *TeacherMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *TeacherMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *TeacherMutation) ResetPassword() {
	m.password = nil
}

// AddClassIDs adds the "classes" edge to the Class entity by ids.
func (m *TeacherMutation) AddClassIDs(ids ...string) {
	if m.classes == nil {
		m.classes = make(map[string]struct{})
	}
	for i := range ids {
		m.classes[ids[i]] = struct{}{}
	}
}

// ClearClasses clears the "classes" edge to the Class entity.
func (m *TeacherMutation) ClearClasses() {
	m.clearedclasses = true
}

// ClassesCleared reports if the "classes" edge to the Class entity was cleared.
func (m *TeacherMutation) ClassesCleared() bool {
	return m.clearedclasses
}

// RemoveClassIDs removes the "classes" edge to the Class entity by IDs.
func (m *TeacherMutation) RemoveClassIDs(ids ...string) {
	if m.removedclasses == nil {
		m.removedclasses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.classes, ids[i])
		m.removedclasses[ids[i]] = struct{}{}
	}
}

// RemovedClasses returns the removed IDs of the "classes" edge to the Class entity.
func (m *TeacherMutation) RemovedClassesIDs() (ids []string) {
	for id := range m.removedclasses {
		ids = append(ids, id)
	}
	return
}

// ClassesIDs returns the "classes" edge IDs in the mutation.
func (m *TeacherMutation) ClassesIDs() (ids []string) {
	for id := range m.classes {
		ids = append(ids, id)
	}
	return
}

// ResetClasses resets all changes to the "classes" edge.
func (m *TeacherMutation) ResetClasses() {
	m.classes = nil
	m.clearedclasses = false
	m.removedclasses = nil
}

// Where appends a list predicates to the TeacherMutation builder.
func (m *TeacherMutation) Where(ps ...predicate.Teacher) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeacherMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Teacher).
func (m *TeacherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeacherMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, teacher.FieldName)
	}
	if m.last_name != nil {
		fields = append(fields, teacher.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, teacher.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, teacher.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeacherMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teacher.FieldName:
		return m.Name()
	case teacher.FieldLastName:
		return m.LastName()
	case teacher.FieldEmail:
		return m.Email()
	case teacher.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeacherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teacher.FieldName:
		return m.OldName(ctx)
	case teacher.FieldLastName:
		return m.OldLastName(ctx)
	case teacher.FieldEmail:
		return m.OldEmail(ctx)
	case teacher.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Teacher field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeacherMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teacher.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case teacher.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case teacher.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case teacher.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Teacher field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeacherMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeacherMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeacherMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Teacher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeacherMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeacherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeacherMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Teacher nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeacherMutation) ResetField(name string) error {
	switch name {
	case teacher.FieldName:
		m.ResetName()
		return nil
	case teacher.FieldLastName:
		m.ResetLastName()
		return nil
	case teacher.FieldEmail:
		m.ResetEmail()
		return nil
	case teacher.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Teacher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeacherMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.classes != nil {
		edges = append(edges, teacher.EdgeClasses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeacherMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teacher.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.classes))
		for id := range m.classes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeacherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedclasses != nil {
		edges = append(edges, teacher.EdgeClasses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeacherMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case teacher.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.removedclasses))
		for id := range m.removedclasses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeacherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedclasses {
		edges = append(edges, teacher.EdgeClasses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeacherMutation) EdgeCleared(name string) bool {
	switch name {
	case teacher.EdgeClasses:
		return m.clearedclasses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeacherMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Teacher unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeacherMutation) ResetEdge(name string) error {
	switch name {
	case teacher.EdgeClasses:
		m.ResetClasses()
		return nil
	}
	return fmt.Errorf("unknown Teacher edge %s", name)
}

// YearMutation represents an operation that mutates the Year nodes in the graph.
type YearMutation struct {
	config
	op             Op
	typ            string
	id             *string
	value          *int
	addvalue       *int
	clearedFields  map[string]struct{}
	classes        map[string]struct{}
	removedclasses map[string]struct{}
	clearedclasses bool
	periods        map[string]struct{}
	removedperiods map[string]struct{}
	clearedperiods bool
	areas          map[string]struct{}
	removedareas   map[string]struct{}
	clearedareas   bool
	done           bool
	oldValue       func(context.Context) (*Year, error)
	predicates     []predicate.Year
}

var _ ent.Mutation = (*YearMutation)(nil)

// yearOption allows management of the mutation configuration using functional options.
type yearOption func(*YearMutation)

// newYearMutation creates new mutation for the Year entity.
func newYearMutation(c config, op Op, opts ...yearOption) *YearMutation {
	m := &YearMutation{
		config:        c,
		op:            op,
		typ:           TypeYear,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withYearID sets the ID field of the mutation.
func withYearID(id string) yearOption {
	return func(m *YearMutation) {
		var (
			err   error
			once  sync.Once
			value *Year
		)
		m.oldValue = func(ctx context.Context) (*Year, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Year.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withYear sets the old Year of the mutation.
func withYear(node *Year) yearOption {
	return func(m *YearMutation) {
		m.oldValue = func(context.Context) (*Year, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m YearMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m YearMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Year entities.
func (m *YearMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *YearMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *YearMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Year.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetValue sets the "value" field.
func (m *YearMutation) SetValue(i int) {
	m.value = &i
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *YearMutation) Value() (r int, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Year entity.
// If the Year object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *YearMutation) OldValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds i to the "value" field.
func (m *YearMutation) AddValue(i int) {
	if m.addvalue != nil {
		*m.addvalue += i
	} else {
		m.addvalue = &i
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *YearMutation) AddedValue() (r int, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *YearMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// AddClassIDs adds the "classes" edge to the Class entity by ids.
func (m *YearMutation) AddClassIDs(ids ...string) {
	if m.classes == nil {
		m.classes = make(map[string]struct{})
	}
	for i := range ids {
		m.classes[ids[i]] = struct{}{}
	}
}

// ClearClasses clears the "classes" edge to the Class entity.
func (m *YearMutation) ClearClasses() {
	m.clearedclasses = true
}

// ClassesCleared reports if the "classes" edge to the Class entity was cleared.
func (m *YearMutation) ClassesCleared() bool {
	return m.clearedclasses
}

// RemoveClassIDs removes the "classes" edge to the Class entity by IDs.
func (m *YearMutation) RemoveClassIDs(ids ...string) {
	if m.removedclasses == nil {
		m.removedclasses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.classes, ids[i])
		m.removedclasses[ids[i]] = struct{}{}
	}
}

// RemovedClasses returns the removed IDs of the "classes" edge to the Class entity.
func (m *YearMutation) RemovedClassesIDs() (ids []string) {
	for id := range m.removedclasses {
		ids = append(ids, id)
	}
	return
}

// ClassesIDs returns the "classes" edge IDs in the mutation.
func (m *YearMutation) ClassesIDs() (ids []string) {
	for id := range m.classes {
		ids = append(ids, id)
	}
	return
}

// ResetClasses resets all changes to the "classes" edge.
func (m *YearMutation) ResetClasses() {
	m.classes = nil
	m.clearedclasses = false
	m.removedclasses = nil
}

// AddPeriodIDs adds the "periods" edge to the Period entity by ids.
func (m *YearMutation) AddPeriodIDs(ids ...string) {
	if m.periods == nil {
		m.periods = make(map[string]struct{})
	}
	for i := range ids {
		m.periods[ids[i]] = struct{}{}
	}
}

// ClearPeriods clears the "periods" edge to the Period entity.
func (m *YearMutation) ClearPeriods() {
	m.clearedperiods = true
}

// PeriodsCleared reports if the "periods" edge to the Period entity was cleared.
func (m *YearMutation) PeriodsCleared() bool {
	return m.clearedperiods
}

// RemovePeriodIDs removes the "periods" edge to the Period entity by IDs.
func (m *YearMutation) RemovePeriodIDs(ids ...string) {
	if m.removedperiods == nil {
		m.removedperiods = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.periods, ids[i])
		m.removedperiods[ids[i]] = struct{}{}
	}
}

// RemovedPeriods returns the removed IDs of the "periods" edge to the Period entity.
func (m *YearMutation) RemovedPeriodsIDs() (ids []string) {
	for id := range m.removedperiods {
		ids = append(ids, id)
	}
	return
}

// PeriodsIDs returns the "periods" edge IDs in the mutation.
func (m *YearMutation) PeriodsIDs() (ids []string) {
	for id := range m.periods {
		ids = append(ids, id)
	}
	return
}

// ResetPeriods resets all changes to the "periods" edge.
func (m *YearMutation) ResetPeriods() {
	m.periods = nil
	m.clearedperiods = false
	m.removedperiods = nil
}

// AddAreaIDs adds the "areas" edge to the Area entity by ids.
func (m *YearMutation) AddAreaIDs(ids ...string) {
	if m.areas == nil {
		m.areas = make(map[string]struct{})
	}
	for i := range ids {
		m.areas[ids[i]] = struct{}{}
	}
}

// ClearAreas clears the "areas" edge to the Area entity.
func (m *YearMutation) ClearAreas() {
	m.clearedareas = true
}

// AreasCleared reports if the "areas" edge to the Area entity was cleared.
func (m *YearMutation) AreasCleared() bool {
	return m.clearedareas
}

// RemoveAreaIDs removes the "areas" edge to the Area entity by IDs.
func (m *YearMutation) RemoveAreaIDs(ids ...string) {
	if m.removedareas == nil {
		m.removedareas = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.areas, ids[i])
		m.removedareas[ids[i]] = struct{}{}
	}
}

// RemovedAreas returns the removed IDs of the "areas" edge to the Area entity.
func (m *YearMutation) RemovedAreasIDs() (ids []string) {
	for id := range m.removedareas {
		ids = append(ids, id)
	}
	return
}

// AreasIDs returns the "areas" edge IDs in the mutation.
func (m *YearMutation) AreasIDs() (ids []string) {
	for id := range m.areas {
		ids = append(ids, id)
	}
	return
}

// ResetAreas resets all changes to the "areas" edge.
func (m *YearMutation) ResetAreas() {
	m.areas = nil
	m.clearedareas = false
	m.removedareas = nil
}

// Where appends a list predicates to the YearMutation builder.
func (m *YearMutation) Where(ps ...predicate.Year) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *YearMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Year).
func (m *YearMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *YearMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.value != nil {
		fields = append(fields, year.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *YearMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case year.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *YearMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case year.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Year field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *YearMutation) SetField(name string, value ent.Value) error {
	switch name {
	case year.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Year field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *YearMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, year.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *YearMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case year.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *YearMutation) AddField(name string, value ent.Value) error {
	switch name {
	case year.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown Year numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *YearMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *YearMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *YearMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Year nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *YearMutation) ResetField(name string) error {
	switch name {
	case year.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Year field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *YearMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.classes != nil {
		edges = append(edges, year.EdgeClasses)
	}
	if m.periods != nil {
		edges = append(edges, year.EdgePeriods)
	}
	if m.areas != nil {
		edges = append(edges, year.EdgeAreas)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *YearMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case year.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.classes))
		for id := range m.classes {
			ids = append(ids, id)
		}
		return ids
	case year.EdgePeriods:
		ids := make([]ent.Value, 0, len(m.periods))
		for id := range m.periods {
			ids = append(ids, id)
		}
		return ids
	case year.EdgeAreas:
		ids := make([]ent.Value, 0, len(m.areas))
		for id := range m.areas {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *YearMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedclasses != nil {
		edges = append(edges, year.EdgeClasses)
	}
	if m.removedperiods != nil {
		edges = append(edges, year.EdgePeriods)
	}
	if m.removedareas != nil {
		edges = append(edges, year.EdgeAreas)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *YearMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case year.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.removedclasses))
		for id := range m.removedclasses {
			ids = append(ids, id)
		}
		return ids
	case year.EdgePeriods:
		ids := make([]ent.Value, 0, len(m.removedperiods))
		for id := range m.removedperiods {
			ids = append(ids, id)
		}
		return ids
	case year.EdgeAreas:
		ids := make([]ent.Value, 0, len(m.removedareas))
		for id := range m.removedareas {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *YearMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedclasses {
		edges = append(edges, year.EdgeClasses)
	}
	if m.clearedperiods {
		edges = append(edges, year.EdgePeriods)
	}
	if m.clearedareas {
		edges = append(edges, year.EdgeAreas)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *YearMutation) EdgeCleared(name string) bool {
	switch name {
	case year.EdgeClasses:
		return m.clearedclasses
	case year.EdgePeriods:
		return m.clearedperiods
	case year.EdgeAreas:
		return m.clearedareas
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *YearMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Year unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *YearMutation) ResetEdge(name string) error {
	switch name {
	case year.EdgeClasses:
		m.ResetClasses()
		return nil
	case year.EdgePeriods:
		m.ResetPeriods()
		return nil
	case year.EdgeAreas:
		m.ResetAreas()
		return nil
	}
	return fmt.Errorf("unknown Year edge %s", name)
}
